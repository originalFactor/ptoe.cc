[{"title":"[C++] 全排列","url":"/full-sorting.html","content":"有 1∼n 这 n（n&lt;10）个数，现将这 n 个数组成一个 n\r\n位的数，每个数只能用一次，例如 n=2，则 12，21 等都是符合条件的数，但 11\r\n和 22 不行。\r\n问，输入 n 后，将符合条件的所有的 n\r\n位数输出，且按照从小到大顺序输出。\r\n\r\nI/O\r\n输入\r\n一个正整数 n。\r\n样例2\r\n输出\r\n按从小到大输出所有的全排列数，每行一个数（中间用空格隔开）。\r\n样例1 22 1\r\n答案\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int n;map&lt;int, bool&gt; used;void printSort(int deep)&#123;    if(deep&gt;=n)&#123;        cout &lt;&lt; endl;        return;    &#125;    for(int i=1;i&lt;=n;i++)        if(!used[i])&#123;            cout &lt;&lt; i &lt;&lt; &quot; &quot;;            used[i] = true;            printSort(deep+1);            used[i] = false;        &#125;&#125;int main()&#123;    cin &gt;&gt; n;    printSort(0);    return 0;&#125;\r\n简单递归。\r\n"},{"title":"[C++] 找数","url":"/find-the-number.html","content":"有两组数字，请找出第二组数中的哪些数在第一组中出现了，并从小到大输出。\r\n\r\nI/O\r\n输入\r\n\r\n第一行两个整数 n 和 m，分别代表 2 组数的数量。\r\n第二行 n 个正整数。\r\n第三行 m 个正整数。\r\n\r\n样例\r\n7 78 7 9 8 2 6 39 6 8 3 3 2 10\r\n输出\r\n按照要求输出满足条件的数，数与数之间用空格隔开。\r\n样例\r\n2 3 3 6 8 9\r\n数据范围\r\n对于 100% 的数据 1 ≤ n, m ≤ 100000，每个数\r\n ≤ 2 × 109\r\n答案\r\n这题我们用 map 就能很简单的做出来，输入第一组数的时候在 map\r\n中保存哪些数存在，再在输入第二组数的时候将 map 中标记为存在的数存进\r\nvector，最后用 STL 函数 sort 排序，输出即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, bool&gt; f;vector&lt;int&gt; b;int n, m, t;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    while(n--)&#123;        cin &gt;&gt; t;        f[t] = true;    &#125;    while(m--)&#123;        cin &gt;&gt; t;        if(f[t]) b.emplace_back(t);    &#125;    sort(b.begin(), b.end());    for(auto&amp; a : b) cout &lt;&lt; a &lt;&lt; &quot; &quot;;    return 0;&#125;\r\n"},{"title":"[C++] 士兵排列","url":"/soilders-sort.html","content":"题面\r\n假如你是长官，现在有一些新兵入伍。但是他们不是同时到达军营集合。对于某一个士兵\r\ni（编号从 1 到 n）, 如果 s[i] = 1，那么他从队尾入队，如果\r\ns[i] = 0，那么他从队头入队。当所有士兵入队后，这个时候士兵就有一个排列。然后，从队头到队尾，每个士兵会说出他的能力值\r\na[i]，你需要按照能力值从高到低输出对应的一个排列。\r\n\r\nI/O\r\n输入\r\n对于每组测试样例，\r\n第一行输入一个正整数 $ n (1 n ^5) $，表示士兵的个数。\r\n第二行输入一个字符串 $ s (1 |s| ^5) $，表示士兵入队的方式。\r\n第三行输入 n 个正整数 ai(1 ≤ ai ≤ 109)，表示入完队后每个士兵从头到尾说出他自己的能力值。\r\n保证每个能力值不同，即 ai ≠ aj(i ≠ j, 1 ≤ i, j ≤ n)。\r\n样例\r\n60110106 1 2 4 5 3\r\n输出\r\n对于每组测试样例，输出一行排列，表示按上述要求排好序后的一个排列。\r\n样例\r\n6 3 2 5 1 4\r\n题解\r\n由题意，使用STL Deque双向队列模拟，即可\r\n注：Wayback\r\nMachine的代码似乎有问题，我重写了，和之前的思路不一样;)，但是理论上没问题。另外，我找不到那题的OJ了\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    deque&lt; pair&lt;int, int&gt; &gt; soilders;    int n;    cin &gt;&gt; n;//    cout &lt;&lt; &quot;We got n = &quot; &lt;&lt; n &lt;&lt; endl;    for(int i=0;i&lt;n;i++)&#123;        char type;        cin &gt;&gt; type;//        cout &lt;&lt; &quot;We got soilder &quot; &lt;&lt; i+1 &lt;&lt; &quot; is &quot; &lt;&lt; (type==&#x27;1&#x27;?&quot;Back&quot;:&quot;Front&quot;) &lt;&lt; &quot; inserted.&quot; &lt;&lt; endl;        switch (type) &#123;        case &#x27;1&#x27;:            soilders.emplace_back(i+1, 0);            break;        case &#x27;0&#x27;:            soilders.emplace_front(i+1, 0);            break;        default:            break;        &#125;    &#125;    vector&lt; pair&lt;int, int&gt; &gt; soilders_listed;    soilders_listed.reserve(n);    while(!soilders.empty())&#123;        int identity = soilders.front().first,            ability;        cin &gt;&gt; ability;        soilders_listed.emplace_back(            identity,            ability        );//        cout &lt;&lt; &quot;We got soilder &quot; &lt;&lt; identity &lt;&lt; &quot;&#x27;s ability is &quot; &lt;&lt; ability &lt;&lt; endl;        soilders.pop_front();    &#125;    sort(soilders_listed.begin(), soilders_listed.end(),        [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;            return a.second &gt; b.second;        &#125;    );    for(auto soilder : soilders_listed)&#123;        cout &lt;&lt; soilder.first &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\r\n"},{"title":"[C++] 分糖果","url":"/p7909.html","content":"[P7909 CSP-J 2021]\r\n分糖果 - 洛谷\r\n红太阳幼儿园有 n\r\n个小朋友，你是其中之一。保证 n ≥ 2。\r\n有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿园的小朋友们。\r\n由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿\r\nR 块糖回去。\r\n但是拿的太少不够分的，所以你至少要拿 L 块糖回去。保证 n ≤ L ≤ R。\r\n也就是说，如果你拿了 k\r\n块糖，那么你需要保证 L ≤ k ≤ R。\r\n如果你拿了 k 块糖，你将把这\r\nk\r\n块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有不少于\r\nn 块糖果，幼儿园的所有 n\r\n个小朋友（包括你自己）都从篮子中拿走恰好一块糖，直到篮子里的糖数量少于\r\nn\r\n块。此时篮子里剩余的糖果均归你所有——这些糖果是作为你搬糖果的奖励。\r\n作为幼儿园高质量小朋友，你希望让作为你搬糖果的奖励的糖果数量（而不是你最后获得的总糖果数量！）尽可能多；因此你需要写一个程序，依次输入\r\nn, L, R，并输出你最多能获得多少作为你搬糖果的奖励的糖果数量。\r\n\r\n输入格式\r\n输入一行，包含三个正整数 n, L, R，分别表示小朋友的个数、糖果数量的下界和上界。\r\n输出格式\r\n输出一行一个整数，表示你最多能获得的作为你搬糖果的奖励的糖果数量。\r\n输入输出样例 #1\r\n输入 #1\r\n7 16 23\r\n输出 #1\r\n6\r\n输入输出样例 #2\r\n输入 #2\r\n10 14 18\r\n输出 #2\r\n8\r\n输入输出样例 #3\r\n输入 #3\r\n见附件中的 candy/candy3.in。\r\n输出 #3\r\n见附件中的 candy/candy3.ans。\r\n说明/提示\r\n【样例解释 #1】\r\n拿 k = 20\r\n块糖放入篮子里。\r\n篮子里现在糖果数 20 ≥ n = 7，因此所有小朋友获得一块糖；\r\n篮子里现在糖果数变成 13 ≥ n = 7，因此所有小朋友获得一块糖；\r\n篮子里现在糖果数变成 6 &lt; n = 7，因此这 6\r\n块糖是作为你搬糖果的奖励。\r\n容易发现，你获得的作为你搬糖果的奖励的糖果数量不可能超过\r\n6\r\n块（不然，篮子里的糖果数量最后仍然不少于 n，需要继续每个小朋友拿一块），因此答案是\r\n6。\r\n【样例解释 #2】\r\n容易发现，当你拿的糖数量 k\r\n满足 14 = L ≤ k ≤ R = 18\r\n时，所有小朋友获得一块糖后，剩下的 k − 10\r\n块糖总是作为你搬糖果的奖励的糖果数量，因此拿 k = 18 块是最优解，答案是 8。\r\n【数据范围】\r\n\r\n\r\n\r\n测试点\r\nn≤\r\nR≤\r\nR − L≤\r\n\r\n\r\n\r\n\r\n1\r\n2\r\n5\r\n5\r\n\r\n\r\n2\r\n5\r\n10\r\n10\r\n\r\n\r\n3\r\n103\r\n103\r\n103\r\n\r\n\r\n4\r\n105\r\n105\r\n105\r\n\r\n\r\n5\r\n103\r\n109\r\n0\r\n\r\n\r\n6\r\n103\r\n109\r\n103\r\n\r\n\r\n7\r\n105\r\n109\r\n105\r\n\r\n\r\n8\r\n109\r\n109\r\n109\r\n\r\n\r\n9\r\n109\r\n109\r\n109\r\n\r\n\r\n10\r\n109\r\n109\r\n109\r\n\r\n\r\n\r\n对于所有数据，保证 2 ≤ n ≤ L ≤ R ≤ 109。\r\n【感谢 hack 数据提供】\r\nwangbinfeng\r\n题解\r\n这题其实就是n进制求区间内个位数最大值。\r\n若区间内包含进位则一定能取到n-1，否则右边界即为最大值。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int n, l, r;int main()&#123;    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;    if(r/n-l/n) cout &lt;&lt; n-1;    else cout &lt;&lt; r%n;        return 0;&#125;\r\n"},{"title":"[C++] 一元二次方程","url":"/p9750.html","content":"洛谷 P9750\r\n众所周知，对一元二次方程 ax2 + bx + c = 0, (a ≠ 0)，可以用以下方式求实数解：\r\n\r\n计算 Δ = b2 − 4ac，则:\r\n\r\n若 Δ &lt; 0，则该一元二次方程无实数解。\r\n2. 否则 Δ ≥ 0，此时该一元二次方程有两个实数解\r\n$x _ {1, 2} = \\frac{-b \\pm \\sqrt\r\n\\Delta}{2a}$。\r\n\r\n\r\n例如：\r\n\r\nx2 + x + 1 = 0\r\n无实数解，因为 Δ = 12 − 4 × 1 × 1 = −3 &lt; 0。\r\nx2 − 2x + 1 = 0\r\n有两相等实数解 x1, 2 = 1。\r\nx2 − 3x + 2 = 0\r\n有两互异实数解 x1 = 1, x2 = 2。\r\n\r\n在题面描述中 a 和 b 的最大公因数使用 gcd (a, b) 表示。例如 12 和 18\r\n的最大公因数是 6，即 gcd (12, 18) = 6。\r\n\r\n题目描述\r\n现在给定一个一元二次方程的系数 a, b, c，其中\r\na, b, c\r\n均为整数且 a ≠ 0。你需要判断一元二次方程\r\nax2 + bx + c = 0\r\n是否有实数解，并按要求的格式输出。\r\n在本题中输出有理数 v 时须遵循以下规则：\r\n\r\n由有理数的定义，存在唯一的两个整数 p 和 q，满足 q &gt; 0，gcd (p, q) = 1 且 $v = \\frac pq$。\r\n若 q = 1，则输出\r\n&#123;p&#125;，否则输出 &#123;p&#125;/&#123;q&#125;，其中\r\n&#123;n&#125; 代表整数 n\r\n的值；\r\n例如：\r\n\r\n当 v = −0.5 时，p 和 q 的值分别为 −1 和 2，则应输出 -1/2；\r\n当 v = 0 时，p 和 q 的值分别为 0 和 1，则应输出 0。\r\n\r\n\r\n对于方程的求解，分两种情况讨论：\r\n\r\n若 Δ = b2 − 4ac &lt; 0，则表明方程无实数解，此时你应当输出\r\nNO；\r\n否则 Δ ≥ 0，此时方程有两解（可能相等），记其中较大者为\r\nx，则：\r\n\r\n若 x\r\n为有理数，则按有理数的格式输出 x。\r\n否则根据上文公式，x\r\n可以被唯一表示为 $x = q _ 1 +\r\nq _ 2 \\sqrt r$ 的形式，其中：\r\n- $q _ 1, q _ 2$ 为有理数，且 $q _ 2 &gt; 0$；\r\n\r\nr 为正整数且 r &gt; 1，且不存在正整数 d &gt; 1 使 d2 ∣ r（即 r 不应是 d2 的倍数）；\r\n\r\n\r\n此时：\r\n\r\n若 q1 ≠ 0，则按有理数的格式输出\r\nq1，并再输出一个加号\r\n+；\r\n否则跳过这一步输出；\r\n\r\n随后：\r\n\r\n若 q2 = 1，则输出\r\nsqrt(&#123;r&#125;)；\r\n否则若 q2\r\n为整数，则输出 &#123;q2&#125;*sqrt(&#123;r&#125;)；\r\n否则若 $q _ 3 = \\frac 1{q _ 2}$\r\n为整数，则输出 sqrt(&#123;r&#125;)/&#123;q3&#125;；\r\n否则可以证明存在唯一整数 c, d 满足 c, d &gt; 1, gcd (c, d) = 1\r\n且 $q _ 2 = \\frac cd$，此时输出\r\n&#123;c&#125;*sqrt(&#123;r&#125;)/&#123;d&#125;；\r\n\r\n上述表示中 &#123;n&#125; 代表整数 &#123;n&#125;\r\n的值，详见样例。\r\n如果方程有实数解，则按要求的格式输出两个实数解中的较大者。否则若方程没有实数解，则输出\r\nNO。\r\n\r\n输入格式\r\n输入的第一行包含两个正整数 T, M，分别表示方程数和系数的绝对值上限。\r\n接下来 T\r\n行，每行包含三个整数 a, b, c。\r\n输出格式\r\n输出 T\r\n行，每行包含一个字符串，表示对应询问的答案，格式如题面所述。\r\n每行输出的字符串中间不应包含任何空格。\r\n输入输出样例 #1\r\n输入 #1\r\n9 10001 -1 0-1 -1 -11 -2 11 5 44 4 11 0 -4321 -3 12 -4 11 7 1\r\n输出 #1\r\n1NO1-1-1/212*sqrt(3)3/2+sqrt(5)/21+sqrt(2)/2-7/2+3*sqrt(5)/2\r\n说明/提示\r\n【样例 #2】\r\n见附件中的 uqe/uqe2.in 与\r\nuqe/uqe2.ans。\r\n【数据范围】\r\n对于所有数据有：1 ≤ T ≤ 5000，1 ≤ M ≤ 103，|a|,|b|,|c| ≤ M，a ≠ 0。\r\n\r\n\r\n\r\n测试点编号\r\nM≤\r\n特殊性质 A\r\n特殊性质 B\r\n特殊性质 C\r\n\r\n\r\n\r\n\r\n1\r\n1\r\n是\r\n是\r\n是\r\n\r\n\r\n2\r\n20\r\n否\r\n否\r\n否\r\n\r\n\r\n3\r\n103\r\n是\r\n否\r\n是\r\n\r\n\r\n4\r\n103\r\n是\r\n否\r\n否\r\n\r\n\r\n5\r\n103\r\n否\r\n是\r\n是\r\n\r\n\r\n6\r\n103\r\n否\r\n是\r\n否\r\n\r\n\r\n7, 8\r\n103\r\n否\r\n否\r\n是\r\n\r\n\r\n9, 10\r\n103\r\n否\r\n否\r\n否\r\n\r\n\r\n\r\n其中：\r\n\r\n特殊性质 A：保证 b = 0；\r\n特殊性质 B：保证 c = 0；\r\n特殊性质 C：如果方程有解，那么方程的两个解都是整数。\r\n\r\n题解\r\n这题相当的麻烦啊，要考虑很多边缘情况，比如若求得结果为\r\n$$\r\nx = \\frac {a} {b} + \\frac {c \\sqrt{d}} {e}\r\n$$\r\n要考虑 a = 0、b = 1、c = 0、c = 1、d = 1、e = 1 等等，都要做特判\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int gcd(int a, int b)&#123;    a = abs(a);    b = abs(b);    return b?gcd(b, a%b):a;&#125;const pair&lt;const int, const int&gt; decimalSqrt(int x)&#123;    if(!x) return &#123;0, 1&#125;;    int i = 2, a = x&gt;0?1:-1, b = 1;    map&lt;int, int&gt; Map;    if(x&lt;0) x = -x;    while(x!=1)&#123;        while(!(x%i))&#123;            x /= i;            Map[i]++;        &#125;        i++;    &#125;    for(auto&amp; j : Map)&#123;        a *= pow(j.first, j.second/2);        if(j.second&amp;1) b *= j.first;    &#125;    return &#123;a, b&#125;;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int t, m;    cin &gt;&gt; t &gt;&gt; m;    while(t--)&#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        int delta = b*b - 4*a*c;        if(delta&lt;0)&#123;            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;            continue;        &#125;        b = -b;        const auto&amp; sd = decimalSqrt(delta);        if(sd.second == 1)&#123;            b += a&lt;0?-sd.first:sd.first;        &#125;        if(b)&#123;            if(b%(2*a))&#123;            int g = gcd(b, 2*a);            cout &lt;&lt; (((b&lt;0)^(a&lt;0))?&quot;-&quot;:&quot;&quot;) &lt;&lt; abs(b/g) &lt;&lt; &quot;/&quot; &lt;&lt; abs(2*a/g);            &#125;else cout &lt;&lt; b/(2*a);        &#125;        if(sd.second!=1)&#123;            if(b) cout &lt;&lt; &quot;+&quot;;            int h = gcd(sd.first, 2*a);            int i = abs(sd.first/h);            if(i!=1) cout &lt;&lt; i &lt;&lt; &quot;*&quot;;            cout &lt;&lt; &quot;sqrt(&quot; &lt;&lt; sd.second &lt;&lt; &quot;)&quot;;            if(sd.first%(2*a)) cout &lt;&lt; &quot;/&quot; &lt;&lt; abs(2*a/h);        &#125;        if(!b &amp;&amp; sd.second==1) cout &lt;&lt; 0;        cout &lt;&lt; endl;    &#125;    return 0;&#125;\r\n"},{"title":"[C++] P2853 [USACO06DEC] Cow Picnic S","url":"/p2853.html","content":"K(1 ≤ K ≤ 100)\r\n只奶牛分散在 N(1 ≤ N ≤ 1000)\r\n个牧场．现在她们要集中起来进餐。牧场之间有 M(1 ≤ M ≤ 10000)\r\n条有向路连接，而且不存在起点和终点相同的有向路．她们进餐的地点必须是所有奶牛都可到达的地方。那么，有多少这样的牧场可供进食呢？\r\n\r\n输入格式\r\n第 1\r\n行：三个以空格分隔的整数，分别为：K, N, M。\r\n第 2 行到第 K + 1 行：每行包含一个整数 Ci（1 ≤ Ci ≤ N），表示第\r\ni 头奶牛所在的牧场编号。\r\n第 K + 2 行到第 M + K + 1\r\n行：每行包含两个以空格分隔的整数 A 和 B，表示一条从牧场 A 到牧场 B 的单向路径。（1 ≤ A, B ≤ N, A ≠ B）\r\n输出格式\r\n第一行：一个整数，即所有奶牛都可以到达的牧场数量。\r\n输入输出样例 #1\r\n输入 #1\r\n2 4 4231 21 42 33 4\r\n输出 #1\r\n2\r\n说明/提示\r\n奶牛可以在 3 或 4 号牧场相遇。\r\n题解\r\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;numeric&gt;using namespace std;void dfs(int node, bool *visited, vector&lt;int&gt; *farms_routes, int *farms) &#123;    //cout &lt;&lt; &quot;Visiting node: &quot; &lt;&lt; node &lt;&lt; endl; // Debug statement to track the nodes being visited. Remove in final version.    visited[node] = true;    farms[node]++;    for(auto it : farms_routes[node])&#123;        if(!visited[it])&#123;            dfs(it, visited, farms_routes, farms);        &#125;    &#125;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int n, k, m;    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;    int cows[k];    for (int i = 0; i &lt; k; i++) &#123;        cin &gt;&gt; cows[i];    &#125;    vector&lt;int&gt; farm_routes[n];    for(int i=0; i&lt;m; i++) &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        farm_routes[a-1].push_back(b-1);    &#125;    int farms[n] = &#123;0&#125;;    bool visited[n] = &#123;false&#125;;    for (int i = 0; i &lt; k; i++) &#123;        memset(visited, false, sizeof(visited));        dfs(cows[i]-1, visited, farm_routes, farms);    &#125;    // for (int i = 0; i &lt; n; i++)    // &#123;    //     cout &lt;&lt; farms[i] &lt;&lt; &quot; &quot;;    // &#125;        cout &lt;&lt; accumulate(farms, farms+n, 0, [k](int base, int cows)&#123;        return cows==k?base+1:base;    &#125;);    return 0;&#125;\r\n"},{"title":"[C++] P2782 友好城市","url":"/p2782.html","content":"有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的\r\nN\r\n个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。\r\n\r\n输入格式\r\n第一行，一个整数 N，表示城市数。\r\n第二行到第 N + 1\r\n行，每行两个整数，中间用一个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。\r\n输出格式\r\n仅一行，输出一个整数，表示政府所能批准的最多申请数。\r\n输入输出样例 #1\r\n输入 #1\r\n722 42 610 315 129 817 174 2\r\n输出 #1\r\n4\r\n说明/提示\r\n数据规模与约定\r\n\r\n对于 50% 的数据，1 ≤ N ≤ 5000，0 ≤ xi ≤ 10000。\r\n对于 100% 的数据，1 ≤ N ≤ 2 × 105，0 ≤ xi ≤ 106。\r\n\r\n题解\r\n我还真第一次见动态规划比较慢的题\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    vector&lt; pair&lt;int, int&gt; &gt; cities;    int n;    cin &gt;&gt; n;    cities.reserve(n);    for(int i=0;i&lt;n;i++)&#123;        int s, n;        cin &gt;&gt; s &gt;&gt; n;        cities.emplace_back(s, n);    &#125;    sort(cities.begin(), cities.end());        // debug    // cout &lt;&lt; &quot;debug: &quot; &lt;&lt; endl;    // for(auto &amp;x : cities) cout &lt;&lt; x.second &lt;&lt; &quot; &quot;;    // cout &lt;&lt; endl;        vector&lt;int&gt; tails;    tails.reserve(n);    for(auto &amp;x : cities)&#123;        int lb = distance(tails.begin(), lower_bound(tails.begin(), tails.end(), x.second));        if(lb == (int)tails.size()) tails.emplace_back(x.second);        else tails[lb] = x.second;    &#125;        // debug    // cout &lt;&lt; &quot;tails: &quot; &lt;&lt; endl;    // for(int x : tails) cout &lt;&lt; x &lt;&lt; &quot; &quot;;    // cout &lt;&lt; endl &lt;&lt; &quot;normal output: &quot; &lt;&lt; endl;        cout &lt;&lt; tails.size();        return 0;&#125;\r\n"},{"title":"[C++] P7910 [CSP-J 2021] 插入排序","url":"/p7910.html","content":"插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H\r\n老师刚刚在上课的时候讲了插入排序算法。\r\n\r\n假设比较两个元素的时间为 𝒪(1)，则插入排序可以以 𝒪(n2)\r\n的时间复杂度完成长度为 n\r\n的数组的排序。不妨假设这 n\r\n个数字分别存储在 a1, a2, …, an\r\n之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：\r\n这下面是 C/C++ 的示范代码：\r\nfor (int i = 1; i &lt;= n; i++)    for (int j = i; j &gt;= 2; j--)        if (a[j] &lt; a[j-1]) &#123;            int t = a[j-1];            a[j-1] = a[j];            a[j] = t;        &#125;\r\n这下面是 Pascal 的示范代码：\r\nfor i:=1 to n do    for j:=i downto 2 do        if a[j]&lt;a[j-1] then            begin                t:=a[i];                a[i]:=a[j];                a[j]:=t;            end;\r\n为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H\r\n老师留下了这么一道家庭作业：\r\nH 老师给了一个长度为 n\r\n的数组 a，数组下标从 1 开始，并且数组中的所有元素均为非负整数。小\r\nZ 需要支持在数组 a 上的 Q\r\n次操作，操作共两种，参数分别如下：\r\n1 x v：这是第一种操作，会将\r\na 的第 x 个元素，也就是 ax 的值，修改为\r\nv。保证 1 ≤ x ≤ n，1 ≤ v ≤ 109。注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作。\r\n2 x：这是第二种操作，假设 H\r\n老师按照上面的伪代码对 a 数组进行排序，你需要告诉 H\r\n老师原来 a 的第 x 个元素，也就是 ax，在排序后的新数组所处的位置。保证\r\n1 ≤ x ≤ n。注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作。\r\nH 老师不喜欢过多的修改，所以他保证类型 1 的操作次数不超过 5000。\r\n小 Z 没有学过计算机竞赛，因此小 Z\r\n并不会做这道题。他找到了你来帮助他解决这个问题。\r\n输入格式\r\n第一行，包含两个正整数 n, Q，表示数组长度和操作次数。\r\n第二行，包含 n\r\n个空格分隔的非负整数，其中第 i\r\n个非负整数表示 ai。\r\n接下来 Q 行，每行 2 ∼ 3\r\n个正整数，表示一次操作，操作格式见【题目描述】。\r\n输出格式\r\n对于每一次类型为 2\r\n的询问，输出一行一个正整数表示答案。\r\n输入输出样例 #1\r\n输入 #1\r\n3 43 2 12 31 3 22 22 3\r\n输出 #1\r\n112\r\n说明/提示\r\n【样例解释 #1】\r\n在修改操作之前，假设 H\r\n老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是\r\n3, 2, 1。\r\n在修改操作之后，假设 H\r\n老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是\r\n3, 1, 2。\r\n注意虽然此时 a2 = a3，但是我们不能将其视为相同的元素。\r\n【样例 #2】\r\n见附件中的 sort/sort2.in 与\r\nsort/sort2.ans。\r\n该测试点数据范围同测试点 1 ∼ 2。\r\n【样例 #3】\r\n见附件中的 sort/sort3.in 与\r\nsort/sort3.ans。\r\n该测试点数据范围同测试点 3 ∼ 7。\r\n【样例 #4】\r\n见附件中的 sort/sort4.in 与\r\nsort/sort4.ans。\r\n该测试点数据范围同测试点 12 ∼ 14。\r\n【数据范围】\r\n对于所有测试数据，满足 1 ≤ n ≤ 8000，1 ≤ Q ≤ 2 × 105，1 ≤ x ≤ n，1 ≤ v, ai ≤ 109。\r\n对于所有测试数据，保证在所有 Q 次操作中，至多有 5000 次操作属于类型一。\r\n各测试点的附加限制及分值如下表所示。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n测试点\r\nn≤\r\nQ≤\r\n特殊性质\r\n\r\n\r\n\r\n\r\n1 ∼ 4\r\n10\r\n10\r\n无\r\n\r\n\r\n5 ∼ 9\r\n300\r\n300\r\n无\r\n\r\n\r\n10 ∼ 13\r\n1500\r\n1500\r\n无\r\n\r\n\r\n14 ∼ 16\r\n8000\r\n8000\r\n保证所有输入的 ai, v\r\n互不相同\r\n\r\n\r\n17 ∼ 19\r\n8000\r\n8000\r\n无\r\n\r\n\r\n20 ∼ 22\r\n8000\r\n2 × 105\r\n保证所有输入的 ai, v\r\n互不相同\r\n\r\n\r\n23 ∼ 25\r\n8000\r\n2 × 105\r\n无\r\n\r\n\r\n\r\n题解\r\n最难降复杂度的一集\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n, Q;    cin &gt;&gt; n &gt;&gt; Q;        vector&lt; pair&lt;int, int&gt; &gt; a(n);    for(auto&amp; i : a) cin &gt;&gt; i.first;        vector&lt;pair&lt;int, int&gt;*&gt; b;    b.reserve(n);    for(int i=0;i&lt;n;i++) b.push_back(&amp;a[i]);    stable_sort(b.begin(), b.end(), [](pair&lt;int, int&gt;* a, pair&lt;int, int&gt;* b)&#123;return a-&gt;first &lt; b-&gt;first;&#125;);    for(int i=0;i&lt;n;i++) b[i]-&gt;second = i;        // debug//    cout &lt;&lt; &quot;debug: &quot;;//    for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i].second+1 &lt;&lt; &quot;(&quot; &lt;&lt; i+1 &lt;&lt; &quot;) &quot;;//    cout &lt;&lt; endl;        while(Q--)&#123;        int o;        cin &gt;&gt; o;        switch(o)&#123;        case 1:            &#123;                int x, v;                cin &gt;&gt; x &gt;&gt; v;                x--;                int bv = a[x].first;                for(int i=0;i&lt;n;i++)&#123;                    if(i==x) continue;                    int t = a[i].first;                    if(v&gt;bv)&#123;                        if(                            (i&gt;x&amp;&amp;t==bv) ||                             (t&gt;bv&amp;&amp;t&lt;v) ||                            (i&lt;x&amp;&amp;t==v)                        )                        &#123;                            a[i].second--;                            a[x].second++;                        &#125;                    &#125;else if(v&lt;bv)&#123;                        if(                            (i&lt;x&amp;&amp;t==bv) ||                            (t&lt;bv&amp;&amp;t&gt;v) ||                            (i&gt;x&amp;&amp;t==v)                        )&#123;                            a[i].second++;                            a[x].second--;                        &#125;                    &#125;                &#125;                a[x].first = v;                                // debug//                cout &lt;&lt; &quot;debug: &quot;;//                for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i].second+1 &lt;&lt; &quot;(&quot; &lt;&lt; i+1 &lt;&lt; &quot;) &quot;;//                cout &lt;&lt; endl;            &#125;            break;        case 2:            &#123;                int x;                cin &gt;&gt; x;                x--;                cout &lt;&lt; a[x].second+1 &lt;&lt; endl;            &#125;            break;        &#125;    &#125;        return 0;&#125;\r\n"},{"title":"[C++] P3916 图的遍历","url":"/p3916.html","content":"给出 N 个点，M 条边的有向图，对于每个点 v，令 A(v) 表示从点 v\r\n出发，能到达的编号最大的点。现在请求出 A(1), A(2), …, A(N)\r\n的值。\r\n\r\n输入格式\r\n第 1 行 2 个整数 N, M，表示点数和边数。\r\n接下来 M 行，每行 2 个整数 Ui, Vi，表示边\r\n(Ui, Vi)。点用\r\n1, 2, …, N 编号。\r\n输出格式\r\n一行 N 个整数 A(1), A(2), …, A(N)。\r\n输入输出样例 #1\r\n输入 #1\r\n4 31 22 44 3\r\n输出 #1\r\n4 4 3 4\r\n说明/提示\r\n\r\n对于 60% 的数据，1 ≤ N, M ≤ 103。\r\n对于 100% 的数据，1 ≤ N, M ≤ 105。\r\n\r\n题解\r\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void dfs(    vector&lt;size_t&gt; vec[],     size_t ans[],     size_t i,     size_t begin,    bool visited[])&#123;    for(auto j : vec[i])    &#123;        if(!visited[j])        &#123;            visited[j] = true;            ans[j] = begin;            dfs(vec, ans, j, begin, visited);        &#125;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    size_t n, m;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;size_t&gt; vec[n];    while(m--)    &#123;        size_t u, v;        cin &gt;&gt; u &gt;&gt; v;        vec[v-1].push_back(u-1);    &#125;    size_t ans[n];    bool visited[n] = &#123;false&#125;;    for(size_t i=n; i--; )    &#123;        if(!visited[i])        &#123;            visited[i] = true;            ans[i] = i;            dfs(vec, ans, i, i, visited);        &#125;    &#125;    for(size_t i=0; i&lt;n; i++)        cout &lt;&lt; ans[i]+1 &lt;&lt; &quot; &quot;;    return 0;&#125;\r\n"},{"title":"[CSP-J 2021] 网络连接","url":"/p7911.html","content":"洛谷P7911\r\nTCP/IP 协议是网络通信领域的一项重要协议。\r\n今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。\r\n\r\n在本问题中，计算机分为两大类：\r\n服务机（Server）和客户机（Client）。\r\n服务机负责建立连接，客户机负责加入连接。\r\n需要进行网络连接的计算机共有 n 台，编号为 1 ∼ n，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。\r\n每台机器在尝试建立或加入连接时需要提供一个地址串。\r\n服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。\r\n一个符合规范的地址串应当具有以下特征：\r\n\r\n必须形如 a.b.c.d:e 的格式，其中 a, b, c, d, e\r\n均为非负整数；\r\n0 ≤ a, b, c, d ≤ 255，0 ≤ e ≤ 65535；\r\na, b, c, d, e\r\n均不能含有多余的前导 0。\r\n\r\n相应地，不符合规范的地址串可能具有以下特征：\r\n\r\n不是形如 a.b.c.d:e 格式的字符串，例如含有多于 3 个字符\r\n. 或多于 1 个字符 : 等情况；\r\n整数 a, b, c, d, e\r\n中某一个或多个超出上述范围；\r\n整数 a, b, c, d, e\r\n中某一个或多个含有多余的前导 0。\r\n\r\n例如，地址串 192.168.0.255:80 是符合规范的，但\r\n192.168.0.999:80、192.168.00.1:10、192.168.0.1:088、192:168:0:1.233\r\n均是不符合规范的。\r\n如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。\r\n在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。\r\n由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；\r\n除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。\r\n如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；\r\n如果找不到这样的服务机，则认为这台客户机无法成功加入连接。\r\n请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。\r\n你的任务很简单：\r\n在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。\r\nI/O\r\n输入\r\n第一行，一个正整数 n。\r\n接下来 n 行，每行两个字符串\r\nop, ad，按照编号从小到大给出每台计算机的类型及地址串。\r\n其中 op\r\n保证为字符串 Server 或 Client 之一，ad 为一个长度不超过 25\r\n的，仅由数字、字符 . 和字符 :\r\n组成的非空字符串。\r\n每行的两个字符串之间用恰好一个空格分隔开，每行的末尾没有多余的空格。\r\n样例\r\n15Server 192.168.1.1:8080Server 192.168.1.1:8080Client 192.168.1.1:8080Client 192.168.1.1:80Client 192.168.1.1:99999\r\n210Server 192.168.1.1:80Client 192.168.1.1:80Client 192.168.1.1:8080Server 192.168.1.1:80Server 192.168.1.1:8080Server 192.168.1.999:0Client 192.168.1.1.8080Client 192.168.1.1:8080Client 192.168.1.1:80Client 192.168.1.999:0\r\n输出\r\n输出共 n\r\n行，每行一个正整数或字符串表示第 i 台计算机的连接状态。 其中：\r\n\r\n如果第 i\r\n台计算机为服务机，则：\r\n\r\n如果其提供符合规范的地址串且成功建立连接，输出字符串\r\nOK。\r\n如果其提供符合规范的地址串，但由于先前有相同地址串的服务机而无法成功建立连接，输出字符串\r\nFAIL。\r\n如果其提供的地址串不是符合规范的地址串，输出字符串\r\nERR。\r\n\r\n如果第 i 台计算机为客户机，则：\r\n\r\n如果其提供符合规范的地址串且成功加入连接，输出一个正整数表示这台客户机连接到的服务机的编号。\r\n如果其提供符合规范的地址串，但无法成功加入连接时，输出字符串\r\nFAIL。\r\n如果其提供的地址串不是符合规范的地址串，输出字符串\r\nERR。\r\n\r\n\r\n样例\r\n1OKFAIL1FAILERR\r\n2OK1FAILFAILOKERRERR51ERR\r\n数据范围\r\n\r\n\r\n\r\n测试点编号\r\nn≤\r\n特殊性质\r\n\r\n\r\n\r\n\r\n1\r\n10\r\n1 2 3\r\n\r\n\r\n2~3\r\n100\r\n1 2 3\r\n\r\n\r\n4~5\r\n1000\r\n1 2 3\r\n\r\n\r\n6~8\r\n1000\r\n1 2\r\n\r\n\r\n9~11\r\n1000\r\n1\r\n\r\n\r\n12~13\r\n1000\r\n2\r\n\r\n\r\n14~15\r\n1000\r\n4\r\n\r\n\r\n16~17\r\n1000\r\n5\r\n\r\n\r\n18~20\r\n1000\r\n无\r\n\r\n\r\n\r\n性质： 1. 保证所有的地址串均符合规范 2.\r\n保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同\r\n3. 保证任意一台服务机的编号都小于所有的客户机 4. 保证所有的地址串均形如\r\na.b.c.d:e 的格式，其中 a, b, c, d, e\r\n均为不超过 109\r\n且不含有多余前导 0 的非负整数 5. 保证所有的地址串均形如\r\na.b.c.d:e 的格式，其中 a, b, c, d, e\r\n均为只含有数字的非空字符串\r\n对于 100% 的数据，保证 1 ≤ n ≤ 1000。\r\n样例 1 解释\r\n计算机 1 为服务机，提供符合规范的地址串\r\n192.168.1.1:8080，成功建立连接；\r\n计算机 2 为服务机，提供与计算机 1\r\n相同的地址串，未能成功建立连接；\r\n计算机 3 为客户机，提供符合规范的地址串\r\n192.168.1.1:8080，成功加入连接，并连接到服务机 1；\r\n计算机 4 为客户机，提供符合规范的地址串\r\n192.168.1.1:80，找不到服务机与其连接；\r\n计算机 5 为客户机，提供的地址串 192.168.1.1:99999\r\n不符合规范。\r\n题解\r\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string,int&gt; conns;bool partCheck(string &amp;part, int max, int min)&#123;    if(part.empty())&#123;        //cout &lt;&lt; &quot;Part is empty.&quot; &lt;&lt; endl;        return false;    &#125;    long long value = 0;    for(char c : part)&#123;        if(c&gt;=&#x27;0&#x27; &amp;&amp; c&lt;=&#x27;9&#x27;) value = value*10 + c - &#x27;0&#x27;;        else&#123;            //cout &lt;&lt; &quot;Character out of range.&quot; &lt;&lt; endl;            return false;        &#125;    &#125;    if(value&lt;min || value&gt;max)&#123;        //cout &lt;&lt; &quot;Part value out of range.&quot; &lt;&lt; endl;        return false;    &#125;    part.clear();    do&#123;        part += (char)(value%10 + &#x27;0&#x27;);        value /= 10;    &#125;while(value);    reverse(part.begin(), part.end());    return true;&#125;bool check(string addr)&#123;    int pos = -1, lastPos = -1;    vector&lt;string&gt; parts;    string part;    while((pos = addr.find(&#x27;.&#x27;, pos+1))!=string::npos)&#123;        part = addr.substr(lastPos+1, pos-lastPos-1);        if(!partCheck(part, 255, 0)) return false;        parts.push_back(part);        lastPos = pos;    &#125;    if(parts.size()!=3)&#123;        //cout &lt;&lt; &quot;Quantity of parts wrong.&quot; &lt;&lt; endl;        return false;    &#125;    pos = addr.find(&#x27;:&#x27;);    if(pos==string::npos)&#123;        //cout &lt;&lt; &quot;Colon not found.&quot; &lt;&lt; endl;        return false;    &#125;    part = addr.substr(lastPos+1, pos-lastPos-1);    if(!partCheck(part, 255, 0)) return false;    string port = addr.substr(pos+1);    if(!partCheck(port, 65535, 0)) return false;    string formedAddr = &quot;&quot;;    for(string p : parts) formedAddr += p + &#x27;.&#x27;;    formedAddr += part + &#x27;:&#x27; + port;    if(formedAddr == addr)&#123;        return true;    &#125;else&#123;        //cout &lt;&lt; formedAddr &lt;&lt; &quot; not match.&quot; &lt;&lt; endl;        return false;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    int n;    cin &gt;&gt; n;    for(int i=1;i&lt;=n;i++)&#123;        string op, ad;        cin &gt;&gt; op &gt;&gt; ad;        if(!check(ad))&#123;            cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl;            continue;        &#125;        switch(op[0])&#123;            case &#x27;S&#x27;:                if(conns.count(ad)) cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;                else&#123;                    cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;                    conns[ad] = i;                &#125;                break;            case &#x27;C&#x27;:                if(conns.count(ad)) cout &lt;&lt; conns[ad] &lt;&lt; endl;                else cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\r\n"},{"title":"[C++] 乘方","url":"/p8813.html","content":"P8813 [CSP-J 2022]\r\n乘方 - 洛谷\r\n小文同学刚刚接触了信息学竞赛，有一天她遇到了这样一个题：给定正整数\r\na 和 b，求 ab\r\n的值是多少。\r\nab 即\r\nb 个 a 相乘的值，例如 23 即为 3 个 2\r\n相乘，结果为 2 × 2 × 2 = 8。\r\n“简单！”小文心想，同时很快就写出了一份程序，可是测试时却出现了错误。\r\n小文很快意识到，她的程序里的变量都是 int\r\n类型的。在大多数机器上，int 类型能表示的最大数为 231 − 1，因此只要计算结果超过这个数，她的程序就会出现错误。\r\n由于小文刚刚学会编程，她担心使用 int\r\n计算会出现问题。因此她希望你在 ab 的值超过\r\n109 时，输出一个\r\n-1 进行警示，否则就输出正确的 ab 的值。\r\n然而小文还是不知道怎么实现这份程序，因此她想请你帮忙。\r\n\r\n输入格式\r\n输入共一行，两个正整数 a, b。\r\n输出格式\r\n输出共一行，如果 ab 的值不超过\r\n109，则输出 ab\r\n的值，否则输出 -1。\r\n输入输出样例 #1\r\n输入 #1\r\n10 9\r\n输出 #1\r\n1000000000\r\n输入输出样例 #2\r\n输入 #2\r\n23333 66666\r\n输出 #2\r\n-1\r\n说明/提示\r\n对于 10% 的数据，保证 b = 1。\r\n对于 30% 的数据，保证 b ≤ 2。\r\n对于 60% 的数据，保证 b ≤ 30，ab ≤ 1018。\r\n对于 100% 的数据，保证 1 ≤ a, b ≤ 109。\r\nupd\r\n2022.11.14/2025.04.02：各新增加一组 Hack 数据。\r\n题解\r\n非常简单的快速幂，但是要注意溢出，非常恶心，所以我直接log2计算占用位数，若计算后占用超过\r\n109\r\n需要的二进制位就返回-1\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int qpow(int a, unsigned int b)&#123;    if(!b) return 1;    int c = qpow(a, b/2);    if(c==-1 || log2(c)*2&gt;log2(1e9)) return -1;    int d = c*c*(b&amp;1?a:1);    if(d&gt;(int)1e9) return -1;    return d;&#125;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; qpow(a,b);    return 0;&#125;\r\n"},{"title":"[C++] 公交换乘","url":"/p5661.html","content":"洛谷P5661\r\n著名旅游城市 B\r\n市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：\r\n\r\n在搭乘一次地铁后可以获得一张优惠票，有效期为 45\r\n分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。\r\n在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45\r\n分钟，即：tbus − tsubway ≤ 45\r\n搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车，但每次搭乘公交车只能使用一张优惠券。\r\n搭乘公交车时，如果可以使用优惠票一定会使用优惠票；\r\n如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。\r\n\r\n现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?\r\n\r\nI/O\r\n输入\r\n第一行包含一个正整数 n，代表乘车记录的数量。\r\n接下来的 n 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。\r\n第 i 行\r\n\r\n第 1 个整数代表第 i 条记录乘坐的交通工具，0 代表地铁，1\r\n代表公交车；\r\n第 2 个整数代表第 i 条记录乘车的票价 pi ；\r\n第 3 个整数代表第 i 条记录开始乘车的时间 ti（距 0\r\n时刻的分钟数）。\r\n\r\n我们保证出行记录是按照开始乘车的时间顺序给出的，且\r\n不会有两次乘车记录出现在同一分钟。\r\n样例160 10 31 5 460 12 501 3 960 5 1101 6 135\r\n样例260 5 10 20 160 7 231 18 311 4 381 7 68 \r\n样例360 5 10 6 160 10 231 7 471 4 501 10 55\r\n输出\r\n有一行，包含一个正整数，代表小轩出行的总花费。\r\n样例136\r\n样例232\r\n样例331\r\n数据范围\r\n\r\n对于 30% 的数据，n ≤ 1000，ti ≤ 106。\r\n另有 15% 的数据，ti ≤ 107，pi 都相等。\r\n另有 15% 的数据，ti ≤ 109，pi 都相等。\r\n对于 100% 的数据，n ≤ 105，ti ≤ 109，1 ≤ pi ≤ 1000。\r\n\r\n注意，本题采用官方比赛实际数据，ti 的真实范围为\r\nti ≤ 107，特此声明。\r\n样例解释\r\n样例 1\r\n\r\n第一条记录，在第 3 分钟花费 10 元乘坐地铁。\r\n第二条记录，在第 46\r\n分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。\r\n第三条记录，在第 50 分种花费 12 元乘坐地铁。\r\n第四条记录，在第 96\r\n分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45\r\n分钟，所以优惠票已失效，花费 3 元乘坐公交车。\r\n第五条记录，在第 110 分钟花费 5 元乘坐地铁。\r\n第六条记录，在第 135\r\n分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为\r\n6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6\r\n元乘坐公交车。\r\n\r\n总共花费 36 元。\r\n样例 2\r\n\r\n第一条记录，在第 1 分钟花费 5 元乘坐地铁。\r\n第二条记录，在第 16 分钟花费 20 元乘坐地铁。\r\n第三条记录，在第 23 分钟花费 7 元乘坐地铁。\r\n第四条记录，在第 31\r\n分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。\r\n第五条记录，在第 38\r\n分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。\r\n第六条记录，在第 68\r\n分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。\r\n\r\n总共花费 32 元。\r\n样例 3\r\n\r\n第一条记录，在第 1 分钟花费 5 元乘坐地铁。\r\n第二条记录，在第 16 分钟花费 6 元乘坐地铁。\r\n第三条记录，在第 23 分钟花费 10 元乘坐地铁。\r\n第四条记录，在第 47 分钟乘坐公交车。\r\n此时由于距离第一条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效；\r\n第二，三条记录中的优惠票有效，但本次公交票价为 7\r\n元，高于第二条的优惠票，只有第三条记录中的优惠票可以使用，所以使用第三条记录的优惠票。\r\n第五条记录，在第 50\r\n分钟乘坐公交车，此时第二，三条记录的优惠票有效，但第三条记录的优惠票已经使用，第二条记录的优惠票高于本次公交票价，所以使用第二条记录的优惠票。\r\n第六条记录，在第 55\r\n分钟乘坐公交车，第一条记录的优惠票已失效，第二，三条记录的优惠票已使用，花费\r\n10 元乘坐公交车。\r\n\r\n总共花费 31 元。\r\n答案\r\n链表&amp;模拟搞定，就是指针操作的调试还是比较花时间的\r\n#include &lt;bits/stdc++.h&gt;using namespace std;struct Ticket&#123;    int time;    int value;    Ticket* next;&#125;;Ticket *head = nullptr, *tail = nullptr;int n, m, p, t, s=0;Ticket* delTicket(Ticket* last, Ticket* curr)&#123;    Ticket* next = curr-&gt;next;    if(last!=nullptr) last-&gt;next = next;    if(head==curr) head = next;    if(tail==curr) tail = last;    delete curr;    return next;&#125;int main()&#123;    cin &gt;&gt; n;    while(n--)&#123;        cin &gt;&gt; m &gt;&gt; p &gt;&gt; t;        if(m)&#123;//            cout &lt;&lt; &quot;Taking a bus.&quot; &lt;&lt; endl;            if(head!=nullptr)&#123;                Ticket *curr = head, *last = nullptr;                bool flag = false;                while(curr!=nullptr)&#123;                    if(t - curr-&gt;time &gt; 45) &#123;                        curr = delTicket(last, curr);                        continue;                    &#125;                    if(curr-&gt;value &gt;= p)&#123;//                        cout &lt;&lt; &quot;Using ticket from time &quot; &lt;&lt; curr-&gt;time &lt;&lt; endl;                        flag = true;                        curr = delTicket(last, curr);                        break;                    &#125;                    last = curr;                    curr = curr-&gt;next;                &#125;                if(flag) continue;            &#125;        &#125;else&#123;//            cout &lt;&lt; &quot;Taking a underground.&quot; &lt;&lt; endl;            if(tail==nullptr) head = tail = new Ticket;            else tail = tail-&gt;next = new Ticket;            tail-&gt;time = t;            tail-&gt;value = p;            tail-&gt;next = nullptr;        &#125;//        cout &lt;&lt; &quot;Costs &quot; &lt;&lt; p &lt;&lt; endl;        s += p;    &#125;        cout &lt;&lt; s;    return 0;&#125;\r\n"},{"title":"[C++] 数字游戏","url":"/p5660.html","content":"洛谷P5660\r\n小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串 来玩数字游戏，小\r\nP 同学想要知道字符串中究竟有多少个 1。\r\n注意：01 字符串为每一个字符是 0 或者 1\r\n的字符串，如“101”（不含双引号）为一个长度为 3 的 01 字符串。\r\n\r\nI/O\r\n输入\r\n共一行，包含一个长度为 8 的 01 字符串 s。\r\n样例100010100\r\n样例211111111\r\n样例301010101\r\n输出\r\n共一行，包含一个整数，即 01 字符串中字符 1 的个数。\r\n样例12\r\n样例28\r\n样例34\r\n数据范围\r\n\r\n对于 20% 的数据，保证输入的字符全部为 0。\r\n对于 100% 的数据，输入只可能包含字符 0 和字符 1，字符串长度固定为\r\n8。\r\n\r\n答案\r\n这东西标准库里都有\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    cin &gt;&gt; s;    bitset&lt;8&gt; b(s);    cout &lt;&lt; b.count();        return 0;&#125;\r\n"},{"title":"[C++] 直播获奖","url":"/p7072.html","content":"直播获奖 -\r\n洛谷\r\nNOI2130 即将举行。为了增加观赏性，CCF\r\n决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为\r\nw%，即当前排名前 w%\r\n的选手的最低成绩就是即时的分数线。\r\n更具体地，若当前已评出了 p\r\n个选手的成绩，则当前计划获奖人数为 max (1, ⌊p × w%⌋)，其中\r\nw 是获奖百分比，⌊x⌋ 表示对 x 向下取整，max (x, y) 表示 x 和 y\r\n中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。\r\n作为评测组的技术人员，请你帮 CCF 写一个直播程序。\r\n\r\n输入格式\r\n第一行有两个整数 n, w。分别代表选手总数与获奖率。\r\n第二行有 n\r\n个整数，依次代表逐一评出的选手成绩。\r\n输出格式\r\n只有一行，包含 n\r\n个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。\r\n输入输出样例 #1\r\n输入 #1\r\n10 60200 300 400 500 600 600 0 300 200 100\r\n输出 #1\r\n200 300 400 400 400 500 400 400 300 300\r\n输入输出样例 #2\r\n输入 #2\r\n10 30100 100 600 100 100 100 100 100 100 100\r\n输出 #2\r\n100 100 600 600 600 600 100 100 100 100\r\n说明/提示\r\n样例 1 解释\r\n\r\n数据规模与约定\r\n各测试点的 n 如下表：\r\n\r\n\r\n\r\n测试点编号\r\nn=\r\n\r\n\r\n\r\n\r\n1 ∼ 3\r\n10\r\n\r\n\r\n4 ∼ 6\r\n500\r\n\r\n\r\n7 ∼ 10\r\n2000\r\n\r\n\r\n11 ∼ 17\r\n104\r\n\r\n\r\n18 ∼ 20\r\n105\r\n\r\n\r\n\r\n对于所有测试点，每个选手的成绩均为不超过 600 的非负整数，获奖百分比 w 是一个正整数且 1 ≤ w ≤ 99。\r\n提示\r\n在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的\r\nfloat 、 double，Pascal 中的 real\r\n、 double 、 extended 等）存储获奖比例 w%，则计算 5 × 60% 时的结果可能为 3.000001，也可能为 2.999999，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。\r\n题解\r\nemm，这题感觉有点麻烦，我是用的 std::map\r\n的有序性（因为是红黑树）做的，这样复杂度低非常~多\r\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int, greater&lt;int&gt;&gt; Map;int n, w, p, x, c, b;int main()&#123;    cin &gt;&gt; n &gt;&gt; w;    for(int i=1;i&lt;=n;i++)&#123;        p = max(1, i*w/100);        cin &gt;&gt; x;        Map[x]++;        c = 0;        for(auto&amp; a : Map)&#123;            b = a.first;            c += a.second;            if(c&gt;=p) break;        &#125;        cout &lt;&lt; b &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\r\n过是可以过\r\n"},{"title":"[C++] 优秀的拆分","url":"/p7071.html","content":"洛谷P7071\r\n一般来说，一个正整数可以拆分成若干个正整数的和。\r\n例如，1 = 1，10 = 1 + 2 + 3 + 4 等。对于正整数 n\r\n的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，n\r\n被分解为了若干个不同的 2 的正整数次幂。注意，一个数\r\nx 能被表示成 2 的正整数次幂，当且仅当 x 能通过正整数个 2 相乘在一起得到。\r\n例如，10 = 8 + 2 = 23 + 21\r\n是一个优秀的拆分。但是，7 = 4 + 2 + 1 = 22 + 21 + 20\r\n就不是一个优秀的拆分，因为 1 不是 2 的正整数次幂。\r\n现在，给定正整数 n，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。\r\n\r\n输入格式\r\n输入只有一行，一个整数 n，代表需要判断的数。\r\n输出格式\r\n如果这个数的所有拆分中，存在优秀的拆分。那么，你需要从大到小输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的。\r\n若不存在优秀的拆分，输出 -1。\r\n输入输出样例 #1\r\n输入 #1\r\n6\r\n输出 #1\r\n4 2\r\n输入输出样例 #2\r\n输入 #2\r\n7\r\n输出 #2\r\n-1\r\n说明/提示\r\n样例 1 解释\r\n6 = 4 + 2 = 22 + 21\r\n是一个优秀的拆分。注意，6 = 2 + 2 + 2\r\n不是一个优秀的拆分，因为拆分成的 3\r\n个数不满足每个数互不相同。\r\n\r\n数据规模与约定\r\n\r\n对于 20% 的数据，n ≤ 10。\r\n对于另外 20% 的数据，保证 n 为奇数。\r\n对于另外 20% 的数据，保证 n 为 2 的正整数次幂。\r\n对于 80% 的数据，n ≤ 1024。\r\n对于 100% 的数据，1 ≤ n ≤ 107。\r\n\r\n题解\r\n很明显我们可以注意到，任意正整数表示为二进制后末位为0（即其是偶数），则存在优秀的拆分。\r\n当我们试图从二进制逆向回十进制时，我们对这个数的第n位乘以 2n − 1\r\n，并累加，由此我们可以得出：\r\n$$\r\n\\text{Decimal} = \\sum_{i=0}^{n-1} b_i \\times 2^i\r\n$$\r\n因此，当 b0 = 0\r\n时，又因为 bi ∈ {0, 1}  ∀i，所以此时该数一定存在优秀的拆分。\r\n而且这个拆分就是这个公式去掉所有为0项的结果。\r\n因此我们可以简单的通过位运算拆出来\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    if(n&lt;=0 || n&amp;1)&#123;        cout &lt;&lt; -1;        return 0;    &#125;    int m, x;    while(n&amp;&amp;(m=log2(n)))&#123;        x = 1 &lt;&lt; m;        cout &lt;&lt; x &lt;&lt; &quot; &quot;;        n -= x;    &#125;    return 0;&#125;\r\n"},{"title":"[C++] 解密","url":"/p8814.html","content":"P8814 [CSP-J 2022]\r\n解密 - 洛谷\r\n给定一个正整数 k，有 k 次询问，每次给定三个正整数 ni, ei, di，求两个正整数\r\npi, qi，使\r\nni = pi × qi、ei × di = (pi − 1)(qi − 1) + 1。\r\n\r\n输入格式\r\n第一行一个正整数 k，表示有\r\nk 次询问。\r\n接下来 k 行，第 i 行三个正整数 ni, di, ei。\r\n输出格式\r\n输出 k 行，每行两个正整数\r\npi, qi\r\n表示答案。\r\n为使输出统一，你应当保证 pi ≤ qi。\r\n如果无解，请输出 NO。\r\n输入输出样例 #1\r\n输入 #1\r\n10770 77 5633 1 211545 1 499683 3 227858 3 257723 37 13572 26 11867 17 17829 3 263528 4 109\r\n输出 #1\r\n2 385NONONO11 783 2412 286NONO6 88\r\n说明/提示\r\n【样例 #2】\r\n见附件中的 decode/decode2.in 与\r\ndecode/decode2.ans。\r\n【样例 #3】\r\n见附件中的 decode/decode3.in 与\r\ndecode/decode3.ans。\r\n【样例 #4】\r\n见附件中的 decode/decode4.in 与\r\ndecode/decode4.ans。\r\n【数据范围】\r\n以下记 m = n − e × d + 2。\r\n保证对于 100% 的数据，1 ≤ k ≤ 105，对于任意的\r\n1 ≤ i ≤ k，1 ≤ ni ≤ 1018，1 ≤ ei × di ≤ 1018\r\n，1 ≤ m ≤ 109。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n测试点编号\r\nk≤\r\nn≤\r\nm≤\r\n特殊性质\r\n\r\n\r\n\r\n\r\n1\r\n103\r\n103\r\n103\r\n保证有解\r\n\r\n\r\n2\r\n103\r\n103\r\n103\r\n无\r\n\r\n\r\n3\r\n103\r\n109\r\n6 × 104\r\n保证有解\r\n\r\n\r\n4\r\n103\r\n109\r\n6 × 104\r\n无\r\n\r\n\r\n5\r\n103\r\n109\r\n109\r\n保证有解\r\n\r\n\r\n6\r\n103\r\n109\r\n109\r\n无\r\n\r\n\r\n7\r\n105\r\n1018\r\n109\r\n保证若有解则 p = q\r\n\r\n\r\n8\r\n105\r\n1018\r\n109\r\n保证有解\r\n\r\n\r\n9\r\n105\r\n1018\r\n109\r\n无\r\n\r\n\r\n10\r\n105\r\n1018\r\n109\r\n无\r\n\r\n\r\n\r\n题解\r\n由题可知 $$\r\n\\begin{aligned}\r\ned &amp; = (p-1)(q-1)+1\\\\\r\n&amp; = pq-p-q+1+1 \\\\\r\n&amp; = pq-p-q+2\r\n\\end{aligned}\r\n$$ 又因为 n = pq ，所以\r\ned = n − p − q + 2\r\n又 $$\r\n\\begin{aligned}\r\nm &amp; = n - ed + 2\\\\\r\n&amp; = n - n + p + q -2 + 2\\\\\r\n&amp; = p + q\r\n\\end{aligned}\r\n$$ 所以 $$\r\n\\begin{aligned}\r\ned &amp; = n - (p+q) + 2\\\\\r\n&amp; = n - m + 2\r\n\\end{aligned}\r\n$$ 所以 m = n + 2 − ed\r\n因此可列关于 p, q 的二元一次方程组（\r\nn, m 为已知） $$\r\n\\begin{cases}\r\np + q = m\\\\\r\npq = n\r\n\\end{cases}\r\n$$\r\n解： $$\r\n\\begin{align}\r\np = \\frac n q\\\\\r\n\\frac n q + q = m\\\\\r\nn + q^2 = mq\\\\\r\nq^2 - mq + n = 0\r\n\\end{align}\r\n$$\r\n得到一个一元二次方程，其中 a = 1, b = −m, c = n\r\n，即可求判别式 Δ = b2 − 4ac\r\n。\r\n若 Δ ≥ 0\r\n，则有解，套用一元二次方程求根公式 $q = \\frac\r\n{-b \\pm \\sqrt {\\Delta}} {2a}$ 中较大那个（即 $q = \\frac {-b + \\sqrt {\\Delta}}\r\n{2a}$）即可。\r\n然后计算 $p = \\frac n q$ 即可。\r\n既然我们得到了结论，就把计算过程实现以下，O(k) 复杂度解决。\r\n注意：一定要用long long或者int64_t，不然会溢出！！！\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int k;    cin &gt;&gt; k;        while(k--)&#123;        int64_t n, e, d;        cin &gt;&gt; n &gt;&gt; e &gt;&gt; d;        int64_t m = n + 2 - e*d;        int64_t delta = m*m - 4*n;        int64_t sd = (delta&gt;=0?sqrt(delta):-1);        if(sd&lt;0 || sd*sd != delta) &#123;            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;            continue;        &#125;        int64_t q = (m+sd)/2;        int64_t p = n/q;        cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;    &#125;        return 0;&#125;\r\n"},{"title":"[C++] P1008 [NOIP 1998 普及组] 三连击","url":"/p1008.html","content":"洛谷签到题（真·签到）\r\n\r\n本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。\r\n题目描述\r\n将 1, 2, …, 9 共 9 个数分成 3\r\n组，分别组成 3 个三位数，且使这 3 个三位数构成 1 : 2 : 3 的比例，试求出所有满足条件的 3 个三位数。\r\n输入格式\r\n无\r\n输出格式\r\n若干行，每行 3 个数字。按照每行第\r\n1 个数字升序排列。\r\n输入输出样例 #1\r\n输入 #1\r\n无\r\n输出 #1\r\n192 384 576* * *...* * *（剩余部分不予展示）\r\n说明/提示\r\nNOIP1998 普及组 第一题\r\n题解\r\n我的妈呀没啥好说的，递归就是了\r\n#include &lt;bits/stdc++.h&gt;using namespace std;bool used[10] = &#123;0&#125;;void f(int a, int b, int c)&#123;    if(!(a/100))&#123;        for(int i=1;i&lt;10;i++)             if(!used[i])&#123;                used[i] = true;                f(a*10+i, b, c);                used[i] = false;            &#125;    &#125;    else if(!(b/100))&#123;        for(int i=1;i&lt;10;i++)             if(!used[i])&#123;                used[i] = true;                f(a, b*10+i, c);                used[i] = false;            &#125;    &#125;    else if(!(c/100))&#123;        for(int i=1;i&lt;10;i++)             if(!used[i])&#123;                used[i] = true;                f(a, b, c*10+i);                used[i] = false;            &#125;    &#125;    else if(a*2==b &amp;&amp; a*3==c) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;&#125;int main()&#123;    f(0, 0, 0);    return 0;&#125;\r\n"},{"title":"[C++] 二进制减法","url":"/binary-minus.html","content":"闲着没事研究了下二进制减法。\r\n\r\n二进制加法都知道吧，就是异或+进位。\r\n$$\r\n\\text{binaryAdd}(a, b) =\r\n\\begin{cases}\r\na &amp; \\text{if } b = 0, \\\\\r\n\\text{binaryAdd}(a \\oplus b,\\ (a \\land b) \\ll 1) &amp; \\text{otherwise.}\r\n\\end{cases}\r\n$$\r\n那么同理可得\r\n$$\r\n\\text{binarySub}(a, b) =\r\n\\begin{cases}\r\na &amp; \\text{if } b = 0, \\\\\r\n\\text{binarySub}(a \\oplus b,\\ (\\neg a \\land b) \\ll 1) &amp;\r\n\\text{otherwise.}\r\n\\end{cases}\r\n$$\r\n大夫真是妙手回春啊！\r\n虽然真正计算机中是用补码+加法器直接实现的（）\r\n注： - $ $ 代表 ^，按位异或 - $ $ 代表\r\n&amp;，按位与 - $ $ 代表 ~，按位非 - $ $ 代表\r\n&lt;&lt;，左移\r\nC++ 实现\r\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;void showBinary(const std::string&amp; _, int x, const size_t&amp; digits)&#123;    std::string b;    while(x)&#123;        b += &#x27;0&#x27;+(x&amp;1);        x &gt;&gt;= 1;    &#125;    while(b.length()&lt;digits) b += &#x27;0&#x27;;    for(size_t i=0; i&lt;(b.length() / 2);i++)&#123;        std::swap(b[i], b[b.length()-i-1]);    &#125;    std::cout &lt;&lt; _ &lt;&lt; &quot; = &quot; &lt;&lt; b &lt;&lt; std::endl;&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::cout.tie(0);        // Binary Minus    int a, b, c;    std::cin &gt;&gt; a &gt;&gt; b;        size_t s = std::max((int)log2(a)+1, (int)log2(b)+1);    std::cout &lt;&lt; &quot;s = &quot; &lt;&lt; s &lt;&lt; std::endl;        showBinary(&quot;a&quot;, a, s);    showBinary(&quot;b&quot;, b, s);        while(b)&#123;        c = a^b;        showBinary(&quot;a&quot;, c, s);        b = ((~a)&amp;b) &lt;&lt; 1;        showBinary(&quot;b&quot;, b, s);        a = c;    &#125;        std::cout &lt;&lt; a;    return 0;&#125;\r\n"}]