[{"title":"[C++] 士兵排列","url":"/2025/06/10/soilders-sort.html","content":"题面\r\n假如你是长官，现在有一些新兵入伍。但是他们不是同时到达军营集合。对于某一个士兵\r\ni（编号从 1 到 n）, 如果 s[i] = 1，那么他从队尾入队，如果\r\ns[i] = 0，那么他从队头入队。当所有士兵入队后，这个时候士兵就有一个排列。然后，从队头到队尾，每个士兵会说出他的能力值\r\na[i]，你需要按照能力值从高到低输出对应的一个排列。\r\n\r\nI/O\r\n输入\r\n对于每组测试样例，\r\n第一行输入一个正整数 $ n (1 n ^5) $，表示士兵的个数。\r\n第二行输入一个字符串 $ s (1 |s| ^5) $，表示士兵入队的方式。\r\n第三行输入 n 个正整数 ai(1 ≤ ai ≤ 109)，表示入完队后每个士兵从头到尾说出他自己的能力值。\r\n保证每个能力值不同，即 ai ≠ aj(i ≠ j, 1 ≤ i, j ≤ n)。\r\n样例\r\n60110106 1 2 4 5 3\r\n输出\r\n对于每组测试样例，输出一行排列，表示按上述要求排好序后的一个排列。\r\n样例\r\n6 3 2 5 1 4\r\n题解\r\n由题意，使用STL Deque双向队列模拟，即可\r\n注：Wayback\r\nMachine的代码似乎有问题，我重写了，和之前的思路不一样;)，但是理论上没问题。另外，我找不到那题的OJ了\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    deque&lt; pair&lt;int, int&gt; &gt; soilders;    int n;    cin &gt;&gt; n;//    cout &lt;&lt; &quot;We got n = &quot; &lt;&lt; n &lt;&lt; endl;    for(int i=0;i&lt;n;i++)&#123;        char type;        cin &gt;&gt; type;//        cout &lt;&lt; &quot;We got soilder &quot; &lt;&lt; i+1 &lt;&lt; &quot; is &quot; &lt;&lt; (type==&#x27;1&#x27;?&quot;Back&quot;:&quot;Front&quot;) &lt;&lt; &quot; inserted.&quot; &lt;&lt; endl;        switch (type) &#123;        case &#x27;1&#x27;:            soilders.emplace_back(i+1, 0);            break;        case &#x27;0&#x27;:            soilders.emplace_front(i+1, 0);            break;        default:            break;        &#125;    &#125;    vector&lt; pair&lt;int, int&gt; &gt; soilders_listed;    soilders_listed.reserve(n);    while(!soilders.empty())&#123;        int identity = soilders.front().first,            ability;        cin &gt;&gt; ability;        soilders_listed.emplace_back(            identity,            ability        );//        cout &lt;&lt; &quot;We got soilder &quot; &lt;&lt; identity &lt;&lt; &quot;&#x27;s ability is &quot; &lt;&lt; ability &lt;&lt; endl;        soilders.pop_front();    &#125;    sort(soilders_listed.begin(), soilders_listed.end(),        [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)&#123;            return a.second &gt; b.second;        &#125;    );    for(auto soilder : soilders_listed)&#123;        cout &lt;&lt; soilder.first &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 找数","url":"/2025/06/13/find-the-number.html","content":"有两组数字，请找出第二组数中的哪些数在第一组中出现了，并从小到大输出。\r\n\r\nI/O\r\n输入\r\n\r\n第一行两个整数 n 和 m，分别代表 2 组数的数量。\r\n第二行 n 个正整数。\r\n第三行 m 个正整数。\r\n\r\n样例\r\n7 78 7 9 8 2 6 39 6 8 3 3 2 10\r\n输出\r\n按照要求输出满足条件的数，数与数之间用空格隔开。\r\n样例\r\n2 3 3 6 8 9\r\n数据范围\r\n对于 100% 的数据 1 ≤ n, m ≤ 100000，每个数\r\n ≤ 2 × 109\r\n答案\r\n这题我们用 map 就能很简单的做出来，输入第一组数的时候在 map\r\n中保存哪些数存在，再在输入第二组数的时候将 map 中标记为存在的数存进\r\nvector，最后用 STL 函数 sort 排序，输出即可。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, bool&gt; f;vector&lt;int&gt; b;int n, m, t;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    while(n--)&#123;        cin &gt;&gt; t;        f[t] = true;    &#125;    while(m--)&#123;        cin &gt;&gt; t;        if(f[t]) b.emplace_back(t);    &#125;    sort(b.begin(), b.end());    for(auto&amp; a : b) cout &lt;&lt; a &lt;&lt; &quot; &quot;;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[CSP-J 2021] 网络连接","url":"/2025/06/11/p7911.html","content":"洛谷P7911\r\nTCP/IP 协议是网络通信领域的一项重要协议。\r\n今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。\r\n\r\n在本问题中，计算机分为两大类：\r\n服务机（Server）和客户机（Client）。\r\n服务机负责建立连接，客户机负责加入连接。\r\n需要进行网络连接的计算机共有 n 台，编号为 1 ∼ n，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。\r\n每台机器在尝试建立或加入连接时需要提供一个地址串。\r\n服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。\r\n一个符合规范的地址串应当具有以下特征：\r\n\r\n必须形如 a.b.c.d:e 的格式，其中 a, b, c, d, e\r\n均为非负整数；\r\n0 ≤ a, b, c, d ≤ 255，0 ≤ e ≤ 65535；\r\na, b, c, d, e\r\n均不能含有多余的前导 0。\r\n\r\n相应地，不符合规范的地址串可能具有以下特征：\r\n\r\n不是形如 a.b.c.d:e 格式的字符串，例如含有多于 3 个字符\r\n. 或多于 1 个字符 : 等情况；\r\n整数 a, b, c, d, e\r\n中某一个或多个超出上述范围；\r\n整数 a, b, c, d, e\r\n中某一个或多个含有多余的前导 0。\r\n\r\n例如，地址串 192.168.0.255:80 是符合规范的，但\r\n192.168.0.999:80、192.168.00.1:10、192.168.0.1:088、192:168:0:1.233\r\n均是不符合规范的。\r\n如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。\r\n在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。\r\n由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；\r\n除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。\r\n如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；\r\n如果找不到这样的服务机，则认为这台客户机无法成功加入连接。\r\n请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。\r\n你的任务很简单：\r\n在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。\r\nI/O\r\n输入\r\n第一行，一个正整数 n。\r\n接下来 n 行，每行两个字符串\r\nop, ad，按照编号从小到大给出每台计算机的类型及地址串。\r\n其中 op\r\n保证为字符串 Server 或 Client 之一，ad 为一个长度不超过 25\r\n的，仅由数字、字符 . 和字符 :\r\n组成的非空字符串。\r\n每行的两个字符串之间用恰好一个空格分隔开，每行的末尾没有多余的空格。\r\n样例\r\n15Server 192.168.1.1:8080Server 192.168.1.1:8080Client 192.168.1.1:8080Client 192.168.1.1:80Client 192.168.1.1:99999\r\n210Server 192.168.1.1:80Client 192.168.1.1:80Client 192.168.1.1:8080Server 192.168.1.1:80Server 192.168.1.1:8080Server 192.168.1.999:0Client 192.168.1.1.8080Client 192.168.1.1:8080Client 192.168.1.1:80Client 192.168.1.999:0\r\n输出\r\n输出共 n\r\n行，每行一个正整数或字符串表示第 i 台计算机的连接状态。 其中：\r\n\r\n如果第 i\r\n台计算机为服务机，则：\r\n\r\n如果其提供符合规范的地址串且成功建立连接，输出字符串\r\nOK。\r\n如果其提供符合规范的地址串，但由于先前有相同地址串的服务机而无法成功建立连接，输出字符串\r\nFAIL。\r\n如果其提供的地址串不是符合规范的地址串，输出字符串\r\nERR。\r\n\r\n如果第 i 台计算机为客户机，则：\r\n\r\n如果其提供符合规范的地址串且成功加入连接，输出一个正整数表示这台客户机连接到的服务机的编号。\r\n如果其提供符合规范的地址串，但无法成功加入连接时，输出字符串\r\nFAIL。\r\n如果其提供的地址串不是符合规范的地址串，输出字符串\r\nERR。\r\n\r\n\r\n样例\r\n1OKFAIL1FAILERR\r\n2OK1FAILFAILOKERRERR51ERR\r\n数据范围\r\n\r\n\r\n\r\n测试点编号\r\nn≤\r\n特殊性质\r\n\r\n\r\n\r\n\r\n1\r\n10\r\n1 2 3\r\n\r\n\r\n2~3\r\n100\r\n1 2 3\r\n\r\n\r\n4~5\r\n1000\r\n1 2 3\r\n\r\n\r\n6~8\r\n1000\r\n1 2\r\n\r\n\r\n9~11\r\n1000\r\n1\r\n\r\n\r\n12~13\r\n1000\r\n2\r\n\r\n\r\n14~15\r\n1000\r\n4\r\n\r\n\r\n16~17\r\n1000\r\n5\r\n\r\n\r\n18~20\r\n1000\r\n无\r\n\r\n\r\n\r\n性质： 1. 保证所有的地址串均符合规范 2.\r\n保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同\r\n3. 保证任意一台服务机的编号都小于所有的客户机 4. 保证所有的地址串均形如\r\na.b.c.d:e 的格式，其中 a, b, c, d, e\r\n均为不超过 109\r\n且不含有多余前导 0 的非负整数 5. 保证所有的地址串均形如\r\na.b.c.d:e 的格式，其中 a, b, c, d, e\r\n均为只含有数字的非空字符串\r\n对于 100% 的数据，保证 1 ≤ n ≤ 1000。\r\n样例 1 解释\r\n计算机 1 为服务机，提供符合规范的地址串\r\n192.168.1.1:8080，成功建立连接；\r\n计算机 2 为服务机，提供与计算机 1\r\n相同的地址串，未能成功建立连接；\r\n计算机 3 为客户机，提供符合规范的地址串\r\n192.168.1.1:8080，成功加入连接，并连接到服务机 1；\r\n计算机 4 为客户机，提供符合规范的地址串\r\n192.168.1.1:80，找不到服务机与其连接；\r\n计算机 5 为客户机，提供的地址串 192.168.1.1:99999\r\n不符合规范。\r\n题解\r\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string,int&gt; conns;bool partCheck(string &amp;part, int max, int min)&#123;    if(part.empty())&#123;        //cout &lt;&lt; &quot;Part is empty.&quot; &lt;&lt; endl;        return false;    &#125;    long long value = 0;    for(char c : part)&#123;        if(c&gt;=&#x27;0&#x27; &amp;&amp; c&lt;=&#x27;9&#x27;) value = value*10 + c - &#x27;0&#x27;;        else&#123;            //cout &lt;&lt; &quot;Character out of range.&quot; &lt;&lt; endl;            return false;        &#125;    &#125;    if(value&lt;min || value&gt;max)&#123;        //cout &lt;&lt; &quot;Part value out of range.&quot; &lt;&lt; endl;        return false;    &#125;    part.clear();    do&#123;        part += (char)(value%10 + &#x27;0&#x27;);        value /= 10;    &#125;while(value);    reverse(part.begin(), part.end());    return true;&#125;bool check(string addr)&#123;    int pos = -1, lastPos = -1;    vector&lt;string&gt; parts;    string part;    while((pos = addr.find(&#x27;.&#x27;, pos+1))!=string::npos)&#123;        part = addr.substr(lastPos+1, pos-lastPos-1);        if(!partCheck(part, 255, 0)) return false;        parts.push_back(part);        lastPos = pos;    &#125;    if(parts.size()!=3)&#123;        //cout &lt;&lt; &quot;Quantity of parts wrong.&quot; &lt;&lt; endl;        return false;    &#125;    pos = addr.find(&#x27;:&#x27;);    if(pos==string::npos)&#123;        //cout &lt;&lt; &quot;Colon not found.&quot; &lt;&lt; endl;        return false;    &#125;    part = addr.substr(lastPos+1, pos-lastPos-1);    if(!partCheck(part, 255, 0)) return false;    string port = addr.substr(pos+1);    if(!partCheck(port, 65535, 0)) return false;    string formedAddr = &quot;&quot;;    for(string p : parts) formedAddr += p + &#x27;.&#x27;;    formedAddr += part + &#x27;:&#x27; + port;    if(formedAddr == addr)&#123;        return true;    &#125;else&#123;        //cout &lt;&lt; formedAddr &lt;&lt; &quot; not match.&quot; &lt;&lt; endl;        return false;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    int n;    cin &gt;&gt; n;    for(int i=1;i&lt;=n;i++)&#123;        string op, ad;        cin &gt;&gt; op &gt;&gt; ad;        if(!check(ad))&#123;            cout &lt;&lt; &quot;ERR&quot; &lt;&lt; endl;            continue;        &#125;        switch(op[0])&#123;            case &#x27;S&#x27;:                if(conns.count(ad)) cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;                else&#123;                    cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;                    conns[ad] = i;                &#125;                break;            case &#x27;C&#x27;:                if(conns.count(ad)) cout &lt;&lt; conns[ad] &lt;&lt; endl;                else cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 数字游戏","url":"/2025/06/13/p5660.html","content":"洛谷P5660\r\n小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串 来玩数字游戏，小\r\nP 同学想要知道字符串中究竟有多少个 1。\r\n注意：01 字符串为每一个字符是 0 或者 1\r\n的字符串，如“101”（不含双引号）为一个长度为 3 的 01 字符串。\r\n\r\nI/O\r\n输入\r\n共一行，包含一个长度为 8 的 01 字符串 s。\r\n样例100010100\r\n样例211111111\r\n样例301010101\r\n输出\r\n共一行，包含一个整数，即 01 字符串中字符 1 的个数。\r\n样例12\r\n样例28\r\n样例34\r\n数据范围\r\n\r\n对于 20% 的数据，保证输入的字符全部为 0。\r\n对于 100% 的数据，输入只可能包含字符 0 和字符 1，字符串长度固定为\r\n8。\r\n\r\n答案\r\n这东西标准库里都有\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    cin &gt;&gt; s;    bitset&lt;8&gt; b(s);    cout &lt;&lt; b.count();        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 全排列","url":"/2025/06/13/full-sorting.html","content":"有 1∼n 这 n（n&lt;10）个数，现将这 n 个数组成一个 n\r\n位的数，每个数只能用一次，例如 n=2，则 12，21 等都是符合条件的数，但 11\r\n和 22 不行。\r\n问，输入 n 后，将符合条件的所有的 n\r\n位数输出，且按照从小到大顺序输出。\r\n\r\nI/O\r\n输入\r\n一个正整数 n。\r\n样例2\r\n输出\r\n按从小到大输出所有的全排列数，每行一个数（中间用空格隔开）。\r\n样例1 22 1\r\n答案\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int n;map&lt;int, bool&gt; used;void printSort(int deep)&#123;    if(deep&gt;=n)&#123;        cout &lt;&lt; endl;        return;    &#125;    for(int i=1;i&lt;=n;i++)        if(!used[i])&#123;            cout &lt;&lt; i &lt;&lt; &quot; &quot;;            used[i] = true;            printSort(deep+1);            used[i] = false;        &#125;&#125;int main()&#123;    cin &gt;&gt; n;    printSort(0);    return 0;&#125;\r\n简单递归。\r\n","categories":["编程"]},{"title":"[C++] 公交换乘","url":"/2025/06/13/p5661.html","content":"洛谷P5661\r\n著名旅游城市 B\r\n市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：\r\n\r\n在搭乘一次地铁后可以获得一张优惠票，有效期为 45\r\n分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。\r\n在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45\r\n分钟，即：tbus − tsubway ≤ 45\r\n搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车，但每次搭乘公交车只能使用一张优惠券。\r\n搭乘公交车时，如果可以使用优惠票一定会使用优惠票；\r\n如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。\r\n\r\n现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?\r\n\r\nI/O\r\n输入\r\n第一行包含一个正整数 n，代表乘车记录的数量。\r\n接下来的 n 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。\r\n第 i 行\r\n\r\n第 1 个整数代表第 i 条记录乘坐的交通工具，0 代表地铁，1\r\n代表公交车；\r\n第 2 个整数代表第 i 条记录乘车的票价 pi ；\r\n第 3 个整数代表第 i 条记录开始乘车的时间 ti（距 0\r\n时刻的分钟数）。\r\n\r\n我们保证出行记录是按照开始乘车的时间顺序给出的，且\r\n不会有两次乘车记录出现在同一分钟。\r\n样例160 10 31 5 460 12 501 3 960 5 1101 6 135\r\n样例260 5 10 20 160 7 231 18 311 4 381 7 68 \r\n样例360 5 10 6 160 10 231 7 471 4 501 10 55\r\n输出\r\n有一行，包含一个正整数，代表小轩出行的总花费。\r\n样例136\r\n样例232\r\n样例331\r\n数据范围\r\n\r\n对于 30% 的数据，n ≤ 1000，ti ≤ 106。\r\n另有 15% 的数据，ti ≤ 107，pi 都相等。\r\n另有 15% 的数据，ti ≤ 109，pi 都相等。\r\n对于 100% 的数据，n ≤ 105，ti ≤ 109，1 ≤ pi ≤ 1000。\r\n\r\n注意，本题采用官方比赛实际数据，ti 的真实范围为\r\nti ≤ 107，特此声明。\r\n样例解释\r\n样例 1\r\n\r\n第一条记录，在第 3 分钟花费 10 元乘坐地铁。\r\n第二条记录，在第 46\r\n分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。\r\n第三条记录，在第 50 分种花费 12 元乘坐地铁。\r\n第四条记录，在第 96\r\n分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45\r\n分钟，所以优惠票已失效，花费 3 元乘坐公交车。\r\n第五条记录，在第 110 分钟花费 5 元乘坐地铁。\r\n第六条记录，在第 135\r\n分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为\r\n6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6\r\n元乘坐公交车。\r\n\r\n总共花费 36 元。\r\n样例 2\r\n\r\n第一条记录，在第 1 分钟花费 5 元乘坐地铁。\r\n第二条记录，在第 16 分钟花费 20 元乘坐地铁。\r\n第三条记录，在第 23 分钟花费 7 元乘坐地铁。\r\n第四条记录，在第 31\r\n分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。\r\n第五条记录，在第 38\r\n分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。\r\n第六条记录，在第 68\r\n分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。\r\n\r\n总共花费 32 元。\r\n样例 3\r\n\r\n第一条记录，在第 1 分钟花费 5 元乘坐地铁。\r\n第二条记录，在第 16 分钟花费 6 元乘坐地铁。\r\n第三条记录，在第 23 分钟花费 10 元乘坐地铁。\r\n第四条记录，在第 47 分钟乘坐公交车。\r\n此时由于距离第一条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效；\r\n第二，三条记录中的优惠票有效，但本次公交票价为 7\r\n元，高于第二条的优惠票，只有第三条记录中的优惠票可以使用，所以使用第三条记录的优惠票。\r\n第五条记录，在第 50\r\n分钟乘坐公交车，此时第二，三条记录的优惠票有效，但第三条记录的优惠票已经使用，第二条记录的优惠票高于本次公交票价，所以使用第二条记录的优惠票。\r\n第六条记录，在第 55\r\n分钟乘坐公交车，第一条记录的优惠票已失效，第二，三条记录的优惠票已使用，花费\r\n10 元乘坐公交车。\r\n\r\n总共花费 31 元。\r\n答案\r\n链表&amp;模拟搞定，就是指针操作的调试还是比较花时间的\r\n#include &lt;bits/stdc++.h&gt;using namespace std;struct Ticket&#123;    int time;    int value;    Ticket* next;&#125;;Ticket *head = nullptr, *tail = nullptr;int n, m, p, t, s=0;Ticket* delTicket(Ticket* last, Ticket* curr)&#123;    Ticket* next = curr-&gt;next;    if(last!=nullptr) last-&gt;next = next;    if(head==curr) head = next;    if(tail==curr) tail = last;    delete curr;    return next;&#125;int main()&#123;    cin &gt;&gt; n;    while(n--)&#123;        cin &gt;&gt; m &gt;&gt; p &gt;&gt; t;        if(m)&#123;//            cout &lt;&lt; &quot;Taking a bus.&quot; &lt;&lt; endl;            if(head!=nullptr)&#123;                Ticket *curr = head, *last = nullptr;                bool flag = false;                while(curr!=nullptr)&#123;                    if(t - curr-&gt;time &gt; 45) &#123;                        curr = delTicket(last, curr);                        continue;                    &#125;                    if(curr-&gt;value &gt;= p)&#123;//                        cout &lt;&lt; &quot;Using ticket from time &quot; &lt;&lt; curr-&gt;time &lt;&lt; endl;                        flag = true;                        curr = delTicket(last, curr);                        break;                    &#125;                    last = curr;                    curr = curr-&gt;next;                &#125;                if(flag) continue;            &#125;        &#125;else&#123;//            cout &lt;&lt; &quot;Taking a underground.&quot; &lt;&lt; endl;            if(tail==nullptr) head = tail = new Ticket;            else tail = tail-&gt;next = new Ticket;            tail-&gt;time = t;            tail-&gt;value = p;            tail-&gt;next = nullptr;        &#125;//        cout &lt;&lt; &quot;Costs &quot; &lt;&lt; p &lt;&lt; endl;        s += p;    &#125;        cout &lt;&lt; s;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 优秀的拆分","url":"/2025/06/20/p7071.html","content":"洛谷P7071\r\n一般来说，一个正整数可以拆分成若干个正整数的和。\r\n例如，1 = 1，10 = 1 + 2 + 3 + 4 等。对于正整数 n\r\n的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，n\r\n被分解为了若干个不同的 2 的正整数次幂。注意，一个数\r\nx 能被表示成 2 的正整数次幂，当且仅当 x 能通过正整数个 2 相乘在一起得到。\r\n例如，10 = 8 + 2 = 23 + 21\r\n是一个优秀的拆分。但是，7 = 4 + 2 + 1 = 22 + 21 + 20\r\n就不是一个优秀的拆分，因为 1 不是 2 的正整数次幂。\r\n现在，给定正整数 n，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。\r\n\r\n输入格式\r\n输入只有一行，一个整数 n，代表需要判断的数。\r\n输出格式\r\n如果这个数的所有拆分中，存在优秀的拆分。那么，你需要从大到小输出这个拆分中的每一个数，相邻两个数之间用一个空格隔开。可以证明，在规定了拆分数字的顺序后，该拆分方案是唯一的。\r\n若不存在优秀的拆分，输出 -1。\r\n输入输出样例 #1\r\n输入 #1\r\n6\r\n输出 #1\r\n4 2\r\n输入输出样例 #2\r\n输入 #2\r\n7\r\n输出 #2\r\n-1\r\n说明/提示\r\n样例 1 解释\r\n6 = 4 + 2 = 22 + 21\r\n是一个优秀的拆分。注意，6 = 2 + 2 + 2\r\n不是一个优秀的拆分，因为拆分成的 3\r\n个数不满足每个数互不相同。\r\n\r\n数据规模与约定\r\n\r\n对于 20% 的数据，n ≤ 10。\r\n对于另外 20% 的数据，保证 n 为奇数。\r\n对于另外 20% 的数据，保证 n 为 2 的正整数次幂。\r\n对于 80% 的数据，n ≤ 1024。\r\n对于 100% 的数据，1 ≤ n ≤ 107。\r\n\r\n题解\r\n很明显我们可以注意到，任意正整数表示为二进制后末位为0（即其是偶数），则存在优秀的拆分。\r\n当我们试图从二进制逆向回十进制时，我们对这个数的第n位乘以 2n − 1\r\n，并累加，由此我们可以得出：\r\n$$\r\n\\text{Decimal} = \\sum_{i=0}^{n-1} b_i \\times 2^i\r\n$$\r\n因此，当 b0 = 0\r\n时，又因为 bi ∈ {0, 1}  ∀i，所以此时该数一定存在优秀的拆分。\r\n而且这个拆分就是这个公式去掉所有为0项的结果。\r\n因此我们可以简单的通过位运算拆出来\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    if(n&lt;=0 || n&amp;1)&#123;        cout &lt;&lt; -1;        return 0;    &#125;    int m, x;    while(n&amp;&amp;(m=log2(n)))&#123;        x = 1 &lt;&lt; m;        cout &lt;&lt; x &lt;&lt; &quot; &quot;;        n -= x;    &#125;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 直播获奖","url":"/2025/06/21/p7072.html","content":"直播获奖 -\r\n洛谷\r\nNOI2130 即将举行。为了增加观赏性，CCF\r\n决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为\r\nw%，即当前排名前 w%\r\n的选手的最低成绩就是即时的分数线。\r\n更具体地，若当前已评出了 p\r\n个选手的成绩，则当前计划获奖人数为 max (1, ⌊p × w%⌋)，其中\r\nw 是获奖百分比，⌊x⌋ 表示对 x 向下取整，max (x, y) 表示 x 和 y\r\n中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。\r\n作为评测组的技术人员，请你帮 CCF 写一个直播程序。\r\n\r\n输入格式\r\n第一行有两个整数 n, w。分别代表选手总数与获奖率。\r\n第二行有 n\r\n个整数，依次代表逐一评出的选手成绩。\r\n输出格式\r\n只有一行，包含 n\r\n个非负整数，依次代表选手成绩逐一评出后，即时的获奖分数线。相邻两个整数间用一个空格分隔。\r\n输入输出样例 #1\r\n输入 #1\r\n10 60200 300 400 500 600 600 0 300 200 100\r\n输出 #1\r\n200 300 400 400 400 500 400 400 300 300\r\n输入输出样例 #2\r\n输入 #2\r\n10 30100 100 600 100 100 100 100 100 100 100\r\n输出 #2\r\n100 100 600 600 600 600 100 100 100 100\r\n说明/提示\r\n\r\n\r\n样例1解释\r\n\r\n数据规模与约定\r\n各测试点的 n 如下表：\r\n\r\n\r\n\r\n测试点编号\r\nn=\r\n\r\n\r\n\r\n\r\n1 ∼ 3\r\n10\r\n\r\n\r\n4 ∼ 6\r\n500\r\n\r\n\r\n7 ∼ 10\r\n2000\r\n\r\n\r\n11 ∼ 17\r\n104\r\n\r\n\r\n18 ∼ 20\r\n105\r\n\r\n\r\n\r\n对于所有测试点，每个选手的成绩均为不超过 600 的非负整数，获奖百分比 w 是一个正整数且 1 ≤ w ≤ 99。\r\n提示\r\n在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的\r\nfloat 、 double，Pascal 中的 real\r\n、 double 、 extended 等）存储获奖比例 w%，则计算 5 × 60% 时的结果可能为 3.000001，也可能为 2.999999，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。\r\n题解\r\nemm，这题感觉有点麻烦，我是用的 std::map\r\n的有序性（因为是红黑树）做的，这样复杂度低非常~多\r\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int, greater&lt;int&gt;&gt; Map;int n, w, p, x, c, b;int main()&#123;    cin &gt;&gt; n &gt;&gt; w;    for(int i=1;i&lt;=n;i++)&#123;        p = max(1, i*w/100);        cin &gt;&gt; x;        Map[x]++;        c = 0;        for(auto&amp; a : Map)&#123;            b = a.first;            c += a.second;            if(c&gt;=p) break;        &#125;        cout &lt;&lt; b &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;\r\n过是可以过\r\n","categories":["编程"]},{"title":"[C++] 分糖果","url":"/2025/06/22/p7909.html","content":"[P7909 CSP-J 2021]\r\n分糖果 - 洛谷\r\n红太阳幼儿园有 n\r\n个小朋友，你是其中之一。保证 n ≥ 2。\r\n有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿园的小朋友们。\r\n由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿\r\nR 块糖回去。\r\n但是拿的太少不够分的，所以你至少要拿 L 块糖回去。保证 n ≤ L ≤ R。\r\n也就是说，如果你拿了 k\r\n块糖，那么你需要保证 L ≤ k ≤ R。\r\n如果你拿了 k 块糖，你将把这\r\nk\r\n块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有不少于\r\nn 块糖果，幼儿园的所有 n\r\n个小朋友（包括你自己）都从篮子中拿走恰好一块糖，直到篮子里的糖数量少于\r\nn\r\n块。此时篮子里剩余的糖果均归你所有——这些糖果是作为你搬糖果的奖励。\r\n作为幼儿园高质量小朋友，你希望让作为你搬糖果的奖励的糖果数量（而不是你最后获得的总糖果数量！）尽可能多；因此你需要写一个程序，依次输入\r\nn, L, R，并输出你最多能获得多少作为你搬糖果的奖励的糖果数量。\r\n\r\n输入格式\r\n输入一行，包含三个正整数 n, L, R，分别表示小朋友的个数、糖果数量的下界和上界。\r\n输出格式\r\n输出一行一个整数，表示你最多能获得的作为你搬糖果的奖励的糖果数量。\r\n输入输出样例 #1\r\n输入 #1\r\n7 16 23\r\n输出 #1\r\n6\r\n输入输出样例 #2\r\n输入 #2\r\n10 14 18\r\n输出 #2\r\n8\r\n输入输出样例 #3\r\n输入 #3\r\n见附件中的 candy/candy3.in。\r\n输出 #3\r\n见附件中的 candy/candy3.ans。\r\n说明/提示\r\n【样例解释 #1】\r\n拿 k = 20\r\n块糖放入篮子里。\r\n篮子里现在糖果数 20 ≥ n = 7，因此所有小朋友获得一块糖；\r\n篮子里现在糖果数变成 13 ≥ n = 7，因此所有小朋友获得一块糖；\r\n篮子里现在糖果数变成 6 &lt; n = 7，因此这 6\r\n块糖是作为你搬糖果的奖励。\r\n容易发现，你获得的作为你搬糖果的奖励的糖果数量不可能超过\r\n6\r\n块（不然，篮子里的糖果数量最后仍然不少于 n，需要继续每个小朋友拿一块），因此答案是\r\n6。\r\n【样例解释 #2】\r\n容易发现，当你拿的糖数量 k\r\n满足 14 = L ≤ k ≤ R = 18\r\n时，所有小朋友获得一块糖后，剩下的 k − 10\r\n块糖总是作为你搬糖果的奖励的糖果数量，因此拿 k = 18 块是最优解，答案是 8。\r\n【数据范围】\r\n\r\n\r\n\r\n测试点\r\nn≤\r\nR≤\r\nR − L≤\r\n\r\n\r\n\r\n\r\n1\r\n2\r\n5\r\n5\r\n\r\n\r\n2\r\n5\r\n10\r\n10\r\n\r\n\r\n3\r\n103\r\n103\r\n103\r\n\r\n\r\n4\r\n105\r\n105\r\n105\r\n\r\n\r\n5\r\n103\r\n109\r\n0\r\n\r\n\r\n6\r\n103\r\n109\r\n103\r\n\r\n\r\n7\r\n105\r\n109\r\n105\r\n\r\n\r\n8\r\n109\r\n109\r\n109\r\n\r\n\r\n9\r\n109\r\n109\r\n109\r\n\r\n\r\n10\r\n109\r\n109\r\n109\r\n\r\n\r\n\r\n对于所有数据，保证 2 ≤ n ≤ L ≤ R ≤ 109。\r\n【感谢 hack 数据提供】\r\nwangbinfeng\r\n题解\r\n这题其实就是n进制求区间内个位数最大值。\r\n若区间内包含进位则一定能取到n-1，否则右边界即为最大值。\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int n, l, r;int main()&#123;    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;    if(r/n-l/n) cout &lt;&lt; n-1;    else cout &lt;&lt; r%n;        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 乘方","url":"/2025/06/22/p8813.html","content":"P8813 [CSP-J 2022]\r\n乘方 - 洛谷\r\n小文同学刚刚接触了信息学竞赛，有一天她遇到了这样一个题：给定正整数\r\na 和 b，求 ab\r\n的值是多少。\r\nab 即\r\nb 个 a 相乘的值，例如 23 即为 3 个 2\r\n相乘，结果为 2 × 2 × 2 = 8。\r\n“简单！”小文心想，同时很快就写出了一份程序，可是测试时却出现了错误。\r\n小文很快意识到，她的程序里的变量都是 int\r\n类型的。在大多数机器上，int 类型能表示的最大数为 231 − 1，因此只要计算结果超过这个数，她的程序就会出现错误。\r\n由于小文刚刚学会编程，她担心使用 int\r\n计算会出现问题。因此她希望你在 ab 的值超过\r\n109 时，输出一个\r\n-1 进行警示，否则就输出正确的 ab 的值。\r\n然而小文还是不知道怎么实现这份程序，因此她想请你帮忙。\r\n\r\n输入格式\r\n输入共一行，两个正整数 a, b。\r\n输出格式\r\n输出共一行，如果 ab 的值不超过\r\n109，则输出 ab\r\n的值，否则输出 -1。\r\n输入输出样例 #1\r\n输入 #1\r\n10 9\r\n输出 #1\r\n1000000000\r\n输入输出样例 #2\r\n输入 #2\r\n23333 66666\r\n输出 #2\r\n-1\r\n说明/提示\r\n对于 10% 的数据，保证 b = 1。\r\n对于 30% 的数据，保证 b ≤ 2。\r\n对于 60% 的数据，保证 b ≤ 30，ab ≤ 1018。\r\n对于 100% 的数据，保证 1 ≤ a, b ≤ 109。\r\nupd\r\n2022.11.14/2025.04.02：各新增加一组 Hack 数据。\r\n题解\r\n非常简单的快速幂，但是要注意溢出，非常恶心，所以我直接log2计算占用位数，若计算后占用超过\r\n109\r\n需要的二进制位就返回-1\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int qpow(int a, unsigned int b)&#123;    if(!b) return 1;    int c = qpow(a, b/2);    if(c==-1 || log2(c)*2&gt;log2(1e9)) return -1;    int d = c*c*(b&amp;1?a:1);    if(d&gt;(int)1e9) return -1;    return d;&#125;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; qpow(a,b);    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 一元二次方程","url":"/2025/06/26/p9750.html","content":"洛谷 P9750\r\n众所周知，对一元二次方程 ax2 + bx + c = 0, (a ≠ 0)，可以用以下方式求实数解：\r\n\r\n计算 Δ = b2 − 4ac，则:\r\n\r\n若 Δ &lt; 0，则该一元二次方程无实数解。\r\n2. 否则 Δ ≥ 0，此时该一元二次方程有两个实数解\r\n$x _ {1, 2} = \\frac{-b \\pm \\sqrt\r\n\\Delta}{2a}$。\r\n\r\n\r\n例如：\r\n\r\nx2 + x + 1 = 0\r\n无实数解，因为 Δ = 12 − 4 × 1 × 1 = −3 &lt; 0。\r\nx2 − 2x + 1 = 0\r\n有两相等实数解 x1, 2 = 1。\r\nx2 − 3x + 2 = 0\r\n有两互异实数解 x1 = 1, x2 = 2。\r\n\r\n在题面描述中 a 和 b 的最大公因数使用 gcd (a, b) 表示。例如 12 和 18\r\n的最大公因数是 6，即 gcd (12, 18) = 6。\r\n\r\n题目描述\r\n现在给定一个一元二次方程的系数 a, b, c，其中\r\na, b, c\r\n均为整数且 a ≠ 0。你需要判断一元二次方程\r\nax2 + bx + c = 0\r\n是否有实数解，并按要求的格式输出。\r\n在本题中输出有理数 v 时须遵循以下规则：\r\n\r\n由有理数的定义，存在唯一的两个整数 p 和 q，满足 q &gt; 0，gcd (p, q) = 1 且 $v = \\frac pq$。\r\n若 q = 1，则输出\r\n&#123;p&#125;，否则输出 &#123;p&#125;/&#123;q&#125;，其中\r\n&#123;n&#125; 代表整数 n\r\n的值；\r\n例如：\r\n\r\n当 v = −0.5 时，p 和 q 的值分别为 −1 和 2，则应输出 -1/2；\r\n当 v = 0 时，p 和 q 的值分别为 0 和 1，则应输出 0。\r\n\r\n\r\n对于方程的求解，分两种情况讨论：\r\n\r\n若 Δ = b2 − 4ac &lt; 0，则表明方程无实数解，此时你应当输出\r\nNO；\r\n否则 Δ ≥ 0，此时方程有两解（可能相等），记其中较大者为\r\nx，则：\r\n\r\n若 x\r\n为有理数，则按有理数的格式输出 x。\r\n否则根据上文公式，x\r\n可以被唯一表示为 $x = q _ 1 +\r\nq _ 2 \\sqrt r$ 的形式，其中：\r\n- $q _ 1, q _ 2$ 为有理数，且 $q _ 2 &gt; 0$；\r\n\r\nr 为正整数且 r &gt; 1，且不存在正整数 d &gt; 1 使 d2 ∣ r（即 r 不应是 d2 的倍数）；\r\n\r\n\r\n此时：\r\n\r\n若 q1 ≠ 0，则按有理数的格式输出\r\nq1，并再输出一个加号\r\n+；\r\n否则跳过这一步输出；\r\n\r\n随后：\r\n\r\n若 q2 = 1，则输出\r\nsqrt(&#123;r&#125;)；\r\n否则若 q2\r\n为整数，则输出 &#123;q2&#125;*sqrt(&#123;r&#125;)；\r\n否则若 $q _ 3 = \\frac 1{q _ 2}$\r\n为整数，则输出 sqrt(&#123;r&#125;)/&#123;q3&#125;；\r\n否则可以证明存在唯一整数 c, d 满足 c, d &gt; 1, gcd (c, d) = 1\r\n且 $q _ 2 = \\frac cd$，此时输出\r\n&#123;c&#125;*sqrt(&#123;r&#125;)/&#123;d&#125;；\r\n\r\n上述表示中 &#123;n&#125; 代表整数 &#123;n&#125;\r\n的值，详见样例。\r\n如果方程有实数解，则按要求的格式输出两个实数解中的较大者。否则若方程没有实数解，则输出\r\nNO。\r\n\r\n输入格式\r\n输入的第一行包含两个正整数 T, M，分别表示方程数和系数的绝对值上限。\r\n接下来 T\r\n行，每行包含三个整数 a, b, c。\r\n输出格式\r\n输出 T\r\n行，每行包含一个字符串，表示对应询问的答案，格式如题面所述。\r\n每行输出的字符串中间不应包含任何空格。\r\n输入输出样例 #1\r\n输入 #1\r\n9 10001 -1 0-1 -1 -11 -2 11 5 44 4 11 0 -4321 -3 12 -4 11 7 1\r\n输出 #1\r\n1NO1-1-1/212*sqrt(3)3/2+sqrt(5)/21+sqrt(2)/2-7/2+3*sqrt(5)/2\r\n说明/提示\r\n【样例 #2】\r\n见附件中的 uqe/uqe2.in 与\r\nuqe/uqe2.ans。\r\n【数据范围】\r\n对于所有数据有：1 ≤ T ≤ 5000，1 ≤ M ≤ 103，|a|,|b|,|c| ≤ M，a ≠ 0。\r\n\r\n\r\n\r\n测试点编号\r\nM≤\r\n特殊性质 A\r\n特殊性质 B\r\n特殊性质 C\r\n\r\n\r\n\r\n\r\n1\r\n1\r\n是\r\n是\r\n是\r\n\r\n\r\n2\r\n20\r\n否\r\n否\r\n否\r\n\r\n\r\n3\r\n103\r\n是\r\n否\r\n是\r\n\r\n\r\n4\r\n103\r\n是\r\n否\r\n否\r\n\r\n\r\n5\r\n103\r\n否\r\n是\r\n是\r\n\r\n\r\n6\r\n103\r\n否\r\n是\r\n否\r\n\r\n\r\n7, 8\r\n103\r\n否\r\n否\r\n是\r\n\r\n\r\n9, 10\r\n103\r\n否\r\n否\r\n否\r\n\r\n\r\n\r\n其中：\r\n\r\n特殊性质 A：保证 b = 0；\r\n特殊性质 B：保证 c = 0；\r\n特殊性质 C：如果方程有解，那么方程的两个解都是整数。\r\n\r\n题解\r\n这题相当的麻烦啊，要考虑很多边缘情况，比如若求得结果为\r\n$$\r\nx = \\frac {a} {b} + \\frac {c \\sqrt{d}} {e}\r\n$$\r\n要考虑 a = 0、b = 1、c = 0、c = 1、d = 1、e = 1 等等，都要做特判\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const int gcd(int a, int b)&#123;    a = abs(a);    b = abs(b);    return b?gcd(b, a%b):a;&#125;const pair&lt;const int, const int&gt; decimalSqrt(int x)&#123;    if(!x) return &#123;0, 1&#125;;    int i = 2, a = x&gt;0?1:-1, b = 1;    map&lt;int, int&gt; Map;    if(x&lt;0) x = -x;    while(x!=1)&#123;        while(!(x%i))&#123;            x /= i;            Map[i]++;        &#125;        i++;    &#125;    for(auto&amp; j : Map)&#123;        a *= pow(j.first, j.second/2);        if(j.second&amp;1) b *= j.first;    &#125;    return &#123;a, b&#125;;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int t, m;    cin &gt;&gt; t &gt;&gt; m;    while(t--)&#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        int delta = b*b - 4*a*c;        if(delta&lt;0)&#123;            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;            continue;        &#125;        b = -b;        const auto&amp; sd = decimalSqrt(delta);        if(sd.second == 1)&#123;            b += a&lt;0?-sd.first:sd.first;        &#125;        if(b)&#123;            if(b%(2*a))&#123;            int g = gcd(b, 2*a);            cout &lt;&lt; (((b&lt;0)^(a&lt;0))?&quot;-&quot;:&quot;&quot;) &lt;&lt; abs(b/g) &lt;&lt; &quot;/&quot; &lt;&lt; abs(2*a/g);            &#125;else cout &lt;&lt; b/(2*a);        &#125;        if(sd.second!=1)&#123;            if(b) cout &lt;&lt; &quot;+&quot;;            int h = gcd(sd.first, 2*a);            int i = abs(sd.first/h);            if(i!=1) cout &lt;&lt; i &lt;&lt; &quot;*&quot;;            cout &lt;&lt; &quot;sqrt(&quot; &lt;&lt; sd.second &lt;&lt; &quot;)&quot;;            if(sd.first%(2*a)) cout &lt;&lt; &quot;/&quot; &lt;&lt; abs(2*a/h);        &#125;        if(!b &amp;&amp; sd.second==1) cout &lt;&lt; 0;        cout &lt;&lt; endl;    &#125;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 解密","url":"/2025/06/22/p8814.html","content":"P8814 [CSP-J 2022]\r\n解密 - 洛谷\r\n给定一个正整数 k，有 k 次询问，每次给定三个正整数 ni, ei, di，求两个正整数\r\npi, qi，使\r\nni = pi × qi、ei × di = (pi − 1)(qi − 1) + 1。\r\n\r\n输入格式\r\n第一行一个正整数 k，表示有\r\nk 次询问。\r\n接下来 k 行，第 i 行三个正整数 ni, di, ei。\r\n输出格式\r\n输出 k 行，每行两个正整数\r\npi, qi\r\n表示答案。\r\n为使输出统一，你应当保证 pi ≤ qi。\r\n如果无解，请输出 NO。\r\n输入输出样例 #1\r\n输入 #1\r\n10770 77 5633 1 211545 1 499683 3 227858 3 257723 37 13572 26 11867 17 17829 3 263528 4 109\r\n输出 #1\r\n2 385NONONO11 783 2412 286NONO6 88\r\n说明/提示\r\n【样例 #2】\r\n见附件中的 decode/decode2.in 与\r\ndecode/decode2.ans。\r\n【样例 #3】\r\n见附件中的 decode/decode3.in 与\r\ndecode/decode3.ans。\r\n【样例 #4】\r\n见附件中的 decode/decode4.in 与\r\ndecode/decode4.ans。\r\n【数据范围】\r\n以下记 m = n − e × d + 2。\r\n保证对于 100% 的数据，1 ≤ k ≤ 105，对于任意的\r\n1 ≤ i ≤ k，1 ≤ ni ≤ 1018，1 ≤ ei × di ≤ 1018\r\n，1 ≤ m ≤ 109。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n测试点编号\r\nk≤\r\nn≤\r\nm≤\r\n特殊性质\r\n\r\n\r\n\r\n\r\n1\r\n103\r\n103\r\n103\r\n保证有解\r\n\r\n\r\n2\r\n103\r\n103\r\n103\r\n无\r\n\r\n\r\n3\r\n103\r\n109\r\n6 × 104\r\n保证有解\r\n\r\n\r\n4\r\n103\r\n109\r\n6 × 104\r\n无\r\n\r\n\r\n5\r\n103\r\n109\r\n109\r\n保证有解\r\n\r\n\r\n6\r\n103\r\n109\r\n109\r\n无\r\n\r\n\r\n7\r\n105\r\n1018\r\n109\r\n保证若有解则 p = q\r\n\r\n\r\n8\r\n105\r\n1018\r\n109\r\n保证有解\r\n\r\n\r\n9\r\n105\r\n1018\r\n109\r\n无\r\n\r\n\r\n10\r\n105\r\n1018\r\n109\r\n无\r\n\r\n\r\n\r\n题解\r\n由题可知 $$\r\n\\begin{aligned}\r\ned &amp; = (p-1)(q-1)+1\\\\\r\n&amp; = pq-p-q+1+1 \\\\\r\n&amp; = pq-p-q+2\r\n\\end{aligned}\r\n$$ 又因为 n = pq ，所以\r\ned = n − p − q + 2\r\n又 $$\r\n\\begin{aligned}\r\nm &amp; = n - ed + 2\\\\\r\n&amp; = n - n + p + q -2 + 2\\\\\r\n&amp; = p + q\r\n\\end{aligned}\r\n$$ 所以 $$\r\n\\begin{aligned}\r\ned &amp; = n - (p+q) + 2\\\\\r\n&amp; = n - m + 2\r\n\\end{aligned}\r\n$$ 所以 m = n + 2 − ed\r\n因此可列关于 p, q 的二元一次方程组（\r\nn, m 为已知） $$\r\n\\begin{cases}\r\np + q = m\\\\\r\npq = n\r\n\\end{cases}\r\n$$\r\n解： $$\r\n\\begin{align}\r\np = \\frac n q\\\\\r\n\\frac n q + q = m\\\\\r\nn + q^2 = mq\\\\\r\nq^2 - mq + n = 0\r\n\\end{align}\r\n$$\r\n得到一个一元二次方程，其中 a = 1, b = −m, c = n\r\n，即可求判别式 Δ = b2 − 4ac\r\n。\r\n若 Δ ≥ 0\r\n，则有解，套用一元二次方程求根公式 $q = \\frac\r\n{-b \\pm \\sqrt {\\Delta}} {2a}$ 中较大那个（即 $q = \\frac {-b + \\sqrt {\\Delta}}\r\n{2a}$）即可。\r\n然后计算 $p = \\frac n q$ 即可。\r\n既然我们得到了结论，就把计算过程实现以下，O(k) 复杂度解决。\r\n注意：一定要用long long或者int64_t，不然会溢出！！！\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int k;    cin &gt;&gt; k;        while(k--)&#123;        int64_t n, e, d;        cin &gt;&gt; n &gt;&gt; e &gt;&gt; d;        int64_t m = n + 2 - e*d;        int64_t delta = m*m - 4*n;        int64_t sd = (delta&gt;=0?sqrt(delta):-1);        if(sd&lt;0 || sd*sd != delta) &#123;            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;            continue;        &#125;        int64_t q = (m+sd)/2;        int64_t p = n/q;        cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; endl;    &#125;        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 二进制减法","url":"/2025/07/24/binary-minus.html","content":"闲着没事研究了下二进制减法。\r\n\r\n二进制加法都知道吧，就是异或+进位。\r\n$$\r\n\\text{binaryAdd}(a, b) =\r\n\\begin{cases}\r\na &amp; \\text{if } b = 0, \\\\\r\n\\text{binaryAdd}(a \\oplus b,\\ (a \\land b) \\ll 1) &amp; \\text{otherwise.}\r\n\\end{cases}\r\n$$\r\n那么同理可得\r\n$$\r\n\\text{binarySub}(a, b) =\r\n\\begin{cases}\r\na &amp; \\text{if } b = 0, \\\\\r\n\\text{binarySub}(a \\oplus b,\\ (\\neg a \\land b) \\ll 1) &amp;\r\n\\text{otherwise.}\r\n\\end{cases}\r\n$$\r\n大夫真是妙手回春啊！\r\n虽然真正计算机中是用补码+加法器直接实现的（）\r\n注： - $ $ 代表 ^，按位异或 - $ $ 代表\r\n&amp;，按位与 - $ $ 代表 ~，按位非 - $ $ 代表\r\n&lt;&lt;，左移\r\nC++ 实现\r\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;void showBinary(const std::string&amp; _, int x, const size_t&amp; digits)&#123;    std::string b;    while(x)&#123;        b += &#x27;0&#x27;+(x&amp;1);        x &gt;&gt;= 1;    &#125;    while(b.length()&lt;digits) b += &#x27;0&#x27;;    for(size_t i=0; i&lt;(b.length() / 2);i++)&#123;        std::swap(b[i], b[b.length()-i-1]);    &#125;    std::cout &lt;&lt; _ &lt;&lt; &quot; = &quot; &lt;&lt; b &lt;&lt; std::endl;&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::cout.tie(0);        // Binary Minus    int a, b, c;    std::cin &gt;&gt; a &gt;&gt; b;        size_t s = std::max((int)log2(a)+1, (int)log2(b)+1);    std::cout &lt;&lt; &quot;s = &quot; &lt;&lt; s &lt;&lt; std::endl;        showBinary(&quot;a&quot;, a, s);    showBinary(&quot;b&quot;, b, s);        while(b)&#123;        c = a^b;        showBinary(&quot;a&quot;, c, s);        b = ((~a)&amp;b) &lt;&lt; 1;        showBinary(&quot;b&quot;, b, s);        a = c;    &#125;        std::cout &lt;&lt; a;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P2782 友好城市","url":"/2025/07/24/p2782.html","content":"有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的\r\nN\r\n个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。\r\n\r\n输入格式\r\n第一行，一个整数 N，表示城市数。\r\n第二行到第 N + 1\r\n行，每行两个整数，中间用一个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。\r\n输出格式\r\n仅一行，输出一个整数，表示政府所能批准的最多申请数。\r\n输入输出样例 #1\r\n输入 #1\r\n722 42 610 315 129 817 174 2\r\n输出 #1\r\n4\r\n说明/提示\r\n数据规模与约定\r\n\r\n对于 50% 的数据，1 ≤ N ≤ 5000，0 ≤ xi ≤ 10000。\r\n对于 100% 的数据，1 ≤ N ≤ 2 × 105，0 ≤ xi ≤ 106。\r\n\r\n题解\r\n我还真第一次见动态规划比较慢的题\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    vector&lt; pair&lt;int, int&gt; &gt; cities;    int n;    cin &gt;&gt; n;    cities.reserve(n);    for(int i=0;i&lt;n;i++)&#123;        int s, n;        cin &gt;&gt; s &gt;&gt; n;        cities.emplace_back(s, n);    &#125;    sort(cities.begin(), cities.end());        // debug    // cout &lt;&lt; &quot;debug: &quot; &lt;&lt; endl;    // for(auto &amp;x : cities) cout &lt;&lt; x.second &lt;&lt; &quot; &quot;;    // cout &lt;&lt; endl;        vector&lt;int&gt; tails;    tails.reserve(n);    for(auto &amp;x : cities)&#123;        int lb = distance(tails.begin(), lower_bound(tails.begin(), tails.end(), x.second));        if(lb == (int)tails.size()) tails.emplace_back(x.second);        else tails[lb] = x.second;    &#125;        // debug    // cout &lt;&lt; &quot;tails: &quot; &lt;&lt; endl;    // for(int x : tails) cout &lt;&lt; x &lt;&lt; &quot; &quot;;    // cout &lt;&lt; endl &lt;&lt; &quot;normal output: &quot; &lt;&lt; endl;        cout &lt;&lt; tails.size();        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P2853 [USACO06DEC] Cow Picnic S","url":"/2025/07/24/p2853.html","content":"K(1 ≤ K ≤ 100)\r\n只奶牛分散在 N(1 ≤ N ≤ 1000)\r\n个牧场．现在她们要集中起来进餐。牧场之间有 M(1 ≤ M ≤ 10000)\r\n条有向路连接，而且不存在起点和终点相同的有向路．她们进餐的地点必须是所有奶牛都可到达的地方。那么，有多少这样的牧场可供进食呢？\r\n\r\n输入格式\r\n第 1\r\n行：三个以空格分隔的整数，分别为：K, N, M。\r\n第 2 行到第 K + 1 行：每行包含一个整数 Ci（1 ≤ Ci ≤ N），表示第\r\ni 头奶牛所在的牧场编号。\r\n第 K + 2 行到第 M + K + 1\r\n行：每行包含两个以空格分隔的整数 A 和 B，表示一条从牧场 A 到牧场 B 的单向路径。（1 ≤ A, B ≤ N, A ≠ B）\r\n输出格式\r\n第一行：一个整数，即所有奶牛都可以到达的牧场数量。\r\n输入输出样例 #1\r\n输入 #1\r\n2 4 4231 21 42 33 4\r\n输出 #1\r\n2\r\n说明/提示\r\n奶牛可以在 3 或 4 号牧场相遇。\r\n题解\r\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;numeric&gt;using namespace std;void dfs(int node, bool *visited, vector&lt;int&gt; *farms_routes, int *farms) &#123;    //cout &lt;&lt; &quot;Visiting node: &quot; &lt;&lt; node &lt;&lt; endl; // Debug statement to track the nodes being visited. Remove in final version.    visited[node] = true;    farms[node]++;    for(auto it : farms_routes[node])&#123;        if(!visited[it])&#123;            dfs(it, visited, farms_routes, farms);        &#125;    &#125;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int n, k, m;    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;    int cows[k];    for (int i = 0; i &lt; k; i++) &#123;        cin &gt;&gt; cows[i];    &#125;    vector&lt;int&gt; farm_routes[n];    for(int i=0; i&lt;m; i++) &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        farm_routes[a-1].push_back(b-1);    &#125;    int farms[n] = &#123;0&#125;;    bool visited[n] = &#123;false&#125;;    for (int i = 0; i &lt; k; i++) &#123;        memset(visited, false, sizeof(visited));        dfs(cows[i]-1, visited, farm_routes, farms);    &#125;    // for (int i = 0; i &lt; n; i++)    // &#123;    //     cout &lt;&lt; farms[i] &lt;&lt; &quot; &quot;;    // &#125;        cout &lt;&lt; accumulate(farms, farms+n, 0, [k](int base, int cows)&#123;        return cows==k?base+1:base;    &#125;);    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P1008 [NOIP 1998 普及组] 三连击","url":"/2025/07/24/p1008.html","content":"洛谷签到题（真·签到）\r\n\r\n本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。\r\n题目描述\r\n将 1, 2, …, 9 共 9 个数分成 3\r\n组，分别组成 3 个三位数，且使这 3 个三位数构成 1 : 2 : 3 的比例，试求出所有满足条件的 3 个三位数。\r\n输入格式\r\n无\r\n输出格式\r\n若干行，每行 3 个数字。按照每行第\r\n1 个数字升序排列。\r\n输入输出样例 #1\r\n输入 #1\r\n无\r\n输出 #1\r\n192 384 576* * *...* * *（剩余部分不予展示）\r\n说明/提示\r\nNOIP1998 普及组 第一题\r\n题解\r\n我的妈呀没啥好说的，递归就是了\r\n#include &lt;bits/stdc++.h&gt;using namespace std;bool used[10] = &#123;0&#125;;void f(int a, int b, int c)&#123;    if(!(a/100))&#123;        for(int i=1;i&lt;10;i++)             if(!used[i])&#123;                used[i] = true;                f(a*10+i, b, c);                used[i] = false;            &#125;    &#125;    else if(!(b/100))&#123;        for(int i=1;i&lt;10;i++)             if(!used[i])&#123;                used[i] = true;                f(a, b*10+i, c);                used[i] = false;            &#125;    &#125;    else if(!(c/100))&#123;        for(int i=1;i&lt;10;i++)             if(!used[i])&#123;                used[i] = true;                f(a, b, c*10+i);                used[i] = false;            &#125;    &#125;    else if(a*2==b &amp;&amp; a*3==c) cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl;&#125;int main()&#123;    f(0, 0, 0);    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P3916 图的遍历","url":"/2025/07/24/p3916.html","content":"给出 N 个点，M 条边的有向图，对于每个点 v，令 A(v) 表示从点 v\r\n出发，能到达的编号最大的点。现在请求出 A(1), A(2), …, A(N)\r\n的值。\r\n\r\n输入格式\r\n第 1 行 2 个整数 N, M，表示点数和边数。\r\n接下来 M 行，每行 2 个整数 Ui, Vi，表示边\r\n(Ui, Vi)。点用\r\n1, 2, …, N 编号。\r\n输出格式\r\n一行 N 个整数 A(1), A(2), …, A(N)。\r\n输入输出样例 #1\r\n输入 #1\r\n4 31 22 44 3\r\n输出 #1\r\n4 4 3 4\r\n说明/提示\r\n\r\n对于 60% 的数据，1 ≤ N, M ≤ 103。\r\n对于 100% 的数据，1 ≤ N, M ≤ 105。\r\n\r\n题解\r\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void dfs(    vector&lt;size_t&gt; vec[],     size_t ans[],     size_t i,     size_t begin,    bool visited[])&#123;    for(auto j : vec[i])    &#123;        if(!visited[j])        &#123;            visited[j] = true;            ans[j] = begin;            dfs(vec, ans, j, begin, visited);        &#125;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    size_t n, m;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;size_t&gt; vec[n];    while(m--)    &#123;        size_t u, v;        cin &gt;&gt; u &gt;&gt; v;        vec[v-1].push_back(u-1);    &#125;    size_t ans[n];    bool visited[n] = &#123;false&#125;;    for(size_t i=n; i--; )    &#123;        if(!visited[i])        &#123;            visited[i] = true;            ans[i] = i;            dfs(vec, ans, i, i, visited);        &#125;    &#125;    for(size_t i=0; i&lt;n; i++)        cout &lt;&lt; ans[i]+1 &lt;&lt; &quot; &quot;;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P1001 A+B Problem","url":"/2025/07/25/p1001.html","content":"输入两个整数 a, b，输出它们的和（|a|,|b| ≤ 109）。\r\n\r\n注意\r\n\r\nPascal 使用 integer 会爆掉哦！\r\n有负数哦！\r\nC/C++ 的 main 函数必须是 int\r\n类型。程序正常结束时的返回值必须是 0。这不仅对洛谷其他题目有效，而且也是\r\nNOIP/CSP/NOI 比赛的要求！\r\n\r\n好吧，同志们，我们就从这一题开始，向着大牛的路进发。\r\n\r\n任何一个伟大的思想，都有一个微不足道的开始。\r\n\r\n不熟悉算法竞赛的选手请看这里：\r\n算法竞赛中要求的输出格式中，不能有多余的内容，这也包括了“请输入整数\r\na 和 b”\r\n这一类的提示用户输入信息的内容。若包含了这些内容，将会被认为是\r\nWrong Answer，即洛谷上的\r\nWA。在对比代码输出和标准输出时，系统将忽略每一行结尾的空格，以及最后一行之后多余的换行符。\r\n若因此类问题出现本机似乎输出了正确的结果，但是实际提交结果为错误的现象，请勿认为是洛谷评测机出了问题，而是你的代码中可能存在多余的输出信息。用户可以参考在题目末尾提供的代码。\r\n此外，请善用进入 IDE\r\n模式，以避免不同平台的评测产生差异。\r\n最后，请不要在对应的题目讨论区中发布自己的题解，请发布到题解区域中，否则将处以删除或禁言的处罚。若发现无法提交题解则表明本题题解数量过多，仍不应发布讨论。若您的做法确实与其他所有题解均不一样，请联系管理员添加题解。\r\n输入格式\r\n两个以空格分开的整数。\r\n输出格式\r\n一个整数。\r\n输入输出样例 #1\r\n输入 #1\r\n20 30\r\n输出 #1\r\n50\r\n说明/提示\r\n广告\r\n洛谷出品的算法教材，帮助您更简单的学习基础算法。【官方网店绝赞热卖中！】&gt;&gt;&gt;\r\n\r\n本题各种语言的程序范例：\r\nC #include &lt;stdio.h&gt;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d\\n&quot;, a+b);    return 0;&#125; —————-\r\nC++ #include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123;    int a,b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; a+b &lt;&lt; endl;    return 0;&#125; —————-\r\nPascal var a, b: longint;begin    readln(a,b);    writeln(a+b);end. —————–\r\nPython 3\r\ns = input().split()print(int(s[0]) + int(s[1]))\r\nJava import java.io.*;import java.util.*;public class Main &#123;    public static void main(String args[]) throws Exception &#123;        Scanner cin=new Scanner(System.in);        int a = cin.nextInt(), b = cin.nextInt();        System.out.println(a+b);    &#125;&#125; —————–\r\nJavaScript （Node.js）\r\nconst fs = require(&#x27;fs&#x27;)const data = fs.readFileSync(&#x27;/dev/stdin&#x27;)const result = data.toString(&#x27;ascii&#x27;).trim().split(&#x27; &#x27;).map(x =&gt; parseInt(x)).reduce((a, b) =&gt; a + b, 0)console.log(result)process.exit() // 请注意必须在出口点处加入此行\r\n\r\nRuby\r\na, b = gets.split.map(&amp;:to_i)print a+b\r\n\r\nPHP\r\n&lt;?php$input = trim(file_get_contents(&quot;php://stdin&quot;));list($a, $b) = explode(&#x27; &#x27;, $input);echo $a + $b;\r\n\r\nRust\r\nuse std::io;fn main()&#123;    let mut input=String::new();    io::stdin().read_line(&amp;mut input).unwrap();    let mut s=input.trim().split(&#x27; &#x27;);    let a:i32=s.next().unwrap()               .parse().unwrap();    let b:i32=s.next().unwrap()               .parse().unwrap();    println!(&quot;&#123;&#125;&quot;,a+b);&#125;\r\n\r\nGo\r\npackage mainimport &quot;fmt&quot;func main() &#123;    var a, b int    fmt.Scanf(&quot;%d%d&quot;, &amp;a, &amp;b)    fmt.Println(a+b)&#125;\r\n\r\nC# Mono\r\nusing System;public class APlusB&#123;    private static void Main()&#123;        string[] input = Console.ReadLine().Split(&#x27; &#x27;);        Console.WriteLine(int.Parse(input[0]) + int.Parse(input[1]));    &#125;&#125;\r\n\r\nKotlin\r\nfun main(args: Array&lt;String&gt;) &#123;    val (a, b) = readLine()!!.split(&#x27; &#x27;).map(String::toInt)    println(a + b)&#125;\r\n\r\nHaskell\r\nmain = do    [a, b] &lt;- (map read . words) `fmap` getLine    print (a+b)\r\n\r\nLua\r\na = io.read(&#x27;*n&#x27;)b = io.read(&#x27;*n&#x27;)print(a + b)\r\n\r\nOCaml\r\nScanf.scanf &quot;%i %i\\n&quot; (fun a b -&gt; print_int (a + b))\r\n\r\nJulia\r\nnums = map(x -&gt; parse(Int, x), split(readline(), &quot; &quot;))println(nums[1] + nums[2])\r\n\r\nScala\r\nobject Main extends App &#123;    println(scala.io.StdIn.readLine().split(&quot; &quot;).map(_.toInt).sum)&#125;\r\n\r\nPerl\r\nmy $in = &lt;STDIN&gt;;chomp $in;$in = [split /[\\s,]+/, $in];my $c = $in-&gt;[0] + $in-&gt;[1];print &quot;$c\\n&quot;;\r\n","categories":["编程"]},{"title":"[C++] P7910 [CSP-J 2021] 插入排序","url":"/2025/07/24/p7910.html","content":"插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H\r\n老师刚刚在上课的时候讲了插入排序算法。\r\n\r\n假设比较两个元素的时间为 𝒪(1)，则插入排序可以以 𝒪(n2)\r\n的时间复杂度完成长度为 n\r\n的数组的排序。不妨假设这 n\r\n个数字分别存储在 a1, a2, …, an\r\n之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：\r\n这下面是 C/C++ 的示范代码：\r\nfor (int i = 1; i &lt;= n; i++)    for (int j = i; j &gt;= 2; j--)        if (a[j] &lt; a[j-1]) &#123;            int t = a[j-1];            a[j-1] = a[j];            a[j] = t;        &#125;\r\n这下面是 Pascal 的示范代码：\r\nfor i:=1 to n do    for j:=i downto 2 do        if a[j]&lt;a[j-1] then            begin                t:=a[i];                a[i]:=a[j];                a[j]:=t;            end;\r\n为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H\r\n老师留下了这么一道家庭作业：\r\nH 老师给了一个长度为 n\r\n的数组 a，数组下标从 1 开始，并且数组中的所有元素均为非负整数。小\r\nZ 需要支持在数组 a 上的 Q\r\n次操作，操作共两种，参数分别如下：\r\n1 x v：这是第一种操作，会将\r\na 的第 x 个元素，也就是 ax 的值，修改为\r\nv。保证 1 ≤ x ≤ n，1 ≤ v ≤ 109。注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作。\r\n2 x：这是第二种操作，假设 H\r\n老师按照上面的伪代码对 a 数组进行排序，你需要告诉 H\r\n老师原来 a 的第 x 个元素，也就是 ax，在排序后的新数组所处的位置。保证\r\n1 ≤ x ≤ n。注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作。\r\nH 老师不喜欢过多的修改，所以他保证类型 1 的操作次数不超过 5000。\r\n小 Z 没有学过计算机竞赛，因此小 Z\r\n并不会做这道题。他找到了你来帮助他解决这个问题。\r\n输入格式\r\n第一行，包含两个正整数 n, Q，表示数组长度和操作次数。\r\n第二行，包含 n\r\n个空格分隔的非负整数，其中第 i\r\n个非负整数表示 ai。\r\n接下来 Q 行，每行 2 ∼ 3\r\n个正整数，表示一次操作，操作格式见【题目描述】。\r\n输出格式\r\n对于每一次类型为 2\r\n的询问，输出一行一个正整数表示答案。\r\n输入输出样例 #1\r\n输入 #1\r\n3 43 2 12 31 3 22 22 3\r\n输出 #1\r\n112\r\n说明/提示\r\n【样例解释 #1】\r\n在修改操作之前，假设 H\r\n老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是\r\n3, 2, 1。\r\n在修改操作之后，假设 H\r\n老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是\r\n3, 1, 2。\r\n注意虽然此时 a2 = a3，但是我们不能将其视为相同的元素。\r\n【样例 #2】\r\n见附件中的 sort/sort2.in 与\r\nsort/sort2.ans。\r\n该测试点数据范围同测试点 1 ∼ 2。\r\n【样例 #3】\r\n见附件中的 sort/sort3.in 与\r\nsort/sort3.ans。\r\n该测试点数据范围同测试点 3 ∼ 7。\r\n【样例 #4】\r\n见附件中的 sort/sort4.in 与\r\nsort/sort4.ans。\r\n该测试点数据范围同测试点 12 ∼ 14。\r\n【数据范围】\r\n对于所有测试数据，满足 1 ≤ n ≤ 8000，1 ≤ Q ≤ 2 × 105，1 ≤ x ≤ n，1 ≤ v, ai ≤ 109。\r\n对于所有测试数据，保证在所有 Q 次操作中，至多有 5000 次操作属于类型一。\r\n各测试点的附加限制及分值如下表所示。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n测试点\r\nn≤\r\nQ≤\r\n特殊性质\r\n\r\n\r\n\r\n\r\n1 ∼ 4\r\n10\r\n10\r\n无\r\n\r\n\r\n5 ∼ 9\r\n300\r\n300\r\n无\r\n\r\n\r\n10 ∼ 13\r\n1500\r\n1500\r\n无\r\n\r\n\r\n14 ∼ 16\r\n8000\r\n8000\r\n保证所有输入的 ai, v\r\n互不相同\r\n\r\n\r\n17 ∼ 19\r\n8000\r\n8000\r\n无\r\n\r\n\r\n20 ∼ 22\r\n8000\r\n2 × 105\r\n保证所有输入的 ai, v\r\n互不相同\r\n\r\n\r\n23 ∼ 25\r\n8000\r\n2 × 105\r\n无\r\n\r\n\r\n\r\n题解\r\n最难降复杂度的一集\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n, Q;    cin &gt;&gt; n &gt;&gt; Q;        vector&lt; pair&lt;int, int&gt; &gt; a(n);    for(auto&amp; i : a) cin &gt;&gt; i.first;        vector&lt;pair&lt;int, int&gt;*&gt; b;    b.reserve(n);    for(int i=0;i&lt;n;i++) b.push_back(&amp;a[i]);    stable_sort(b.begin(), b.end(), [](pair&lt;int, int&gt;* a, pair&lt;int, int&gt;* b)&#123;return a-&gt;first &lt; b-&gt;first;&#125;);    for(int i=0;i&lt;n;i++) b[i]-&gt;second = i;        // debug//    cout &lt;&lt; &quot;debug: &quot;;//    for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i].second+1 &lt;&lt; &quot;(&quot; &lt;&lt; i+1 &lt;&lt; &quot;) &quot;;//    cout &lt;&lt; endl;        while(Q--)&#123;        int o;        cin &gt;&gt; o;        switch(o)&#123;        case 1:            &#123;                int x, v;                cin &gt;&gt; x &gt;&gt; v;                x--;                int bv = a[x].first;                for(int i=0;i&lt;n;i++)&#123;                    if(i==x) continue;                    int t = a[i].first;                    if(v&gt;bv)&#123;                        if(                            (i&gt;x&amp;&amp;t==bv) ||                             (t&gt;bv&amp;&amp;t&lt;v) ||                            (i&lt;x&amp;&amp;t==v)                        )                        &#123;                            a[i].second--;                            a[x].second++;                        &#125;                    &#125;else if(v&lt;bv)&#123;                        if(                            (i&lt;x&amp;&amp;t==bv) ||                            (t&lt;bv&amp;&amp;t&gt;v) ||                            (i&gt;x&amp;&amp;t==v)                        )&#123;                            a[i].second++;                            a[x].second--;                        &#125;                    &#125;                &#125;                a[x].first = v;                                // debug//                cout &lt;&lt; &quot;debug: &quot;;//                for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i].second+1 &lt;&lt; &quot;(&quot; &lt;&lt; i+1 &lt;&lt; &quot;) &quot;;//                cout &lt;&lt; endl;            &#125;            break;        case 2:            &#123;                int x;                cin &gt;&gt; x;                x--;                cout &lt;&lt; a[x].second+1 &lt;&lt; endl;            &#125;            break;        &#125;    &#125;        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P1000 超级玛丽游戏","url":"/2025/07/25/p1000.html","content":"本题是洛谷的试机题目，可以帮助了解洛谷的使用。\r\n建议完成本题目后继续尝试 P1001、P1008。\r\n另外强烈推荐新用户必读帖。\r\n\r\n题目描述\r\n超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景：\r\n                ********               ************               ####....#.             #..###.....##....             ###.......######              ###            ###                ...........               #...#          #...#               ##*#######                 #.#.#          #.#.#            ####*******######             #.#.#          #.#.#           ...#***.****.*###....          #...#          #...#           ....**********##.....           ###            ###           ....****    *****....             ####        ####           ######        #####################################################################...#......#.##...#......#.##...#......#.##------------------############################################------------------##..#....#....##..#....#....##..#....#....###############################################################    #----------##.....#......##.....#......##.....#......#    #----------###########################################    #----------##.#..#....#..##.#..#....#..##.#..#....#..#    #----------###########################################    ############\r\n输入格式\r\n无\r\n输出格式\r\n如描述。\r\n输入输出样例 #1\r\n输入 #1\r\n\r\n输出 #1\r\n********               ************               ####....#.             #..###.....##....             ###.......######              ###            ###                ...........               #...#          #...#               ##*#######                 #.#.#          #.#.#            ####*******######             #.#.#          #.#.#           ...#***.****.*###....          #...#          #...#           ....**********##.....           ###            ###           ....****    *****....             ####        ####           ######        #####################################################################...#......#.##...#......#.##...#......#.##------------------############################################------------------##..#....#....##..#....#....##..#....#....###############################################################    #----------##.....#......##.....#......##.....#......#    #----------###########################################    #----------##.#..#....#..##.#..#....#..##.#..#....#..#    #----------###########################################    ############\r\n说明/提示\r\n广告\r\n洛谷出品的算法教材，帮助您更简单的学习基础算法。【官方网店绝赞热卖中！】&gt;&gt;&gt;\r\n\r\n这个直接把输出复制黏贴进去（）\r\n","categories":["编程"]},{"title":"[C++] P3366 【模板】最小生成树","url":"/2025/07/25/p3366.html","content":"如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出\r\norz。\r\n\r\n输入格式\r\n第一行包含两个整数 N, M，表示该图共有 N 个结点和 M 条无向边。\r\n接下来 M 行每行包含三个整数\r\nXi, Yi, Zi，表示有一条长度为\r\nZi\r\n的无向边连接结点 Xi, Yi。\r\n输出格式\r\n如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出\r\norz。\r\n输入输出样例 #1\r\n输入 #1\r\n4 51 2 21 3 21 4 32 3 43 4 3\r\n输出 #1\r\n7\r\n说明/提示\r\n数据规模：\r\n对于 20% 的数据，N ≤ 5，M ≤ 20。\r\n对于 40% 的数据，N ≤ 50，M ≤ 2500。\r\n对于 70% 的数据，N ≤ 500，M ≤ 104。\r\n对于 100% 的数据：1 ≤ N ≤ 5000，1 ≤ M ≤ 2 × 105，1 ≤ Zi ≤ 104。\r\n样例解释：\r\n\r\n所以最小生成树的总边权为 2 + 2 + 3 = 7。\r\n题解\r\n并查集+优先队列\r\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct Edge &#123;    int src, dest, weight;    bool operator&lt;(const Edge&amp; other) const &#123;        return weight &gt; other.weight;    &#125;&#125;;int find(vector&lt;int&gt;&amp; parent, int i) &#123;    if (parent[i] == i) return i;    parent[i] = find(parent, parent[i]);    return parent[i];&#125;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int n, m;    cin &gt;&gt; n &gt;&gt; m;    priority_queue&lt;Edge&gt; edges;    for(int i = 0; i &lt; m; ++i) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        a--; b--;        edges.push(&#123;a, b, c&#125;);    &#125;    vector&lt;int&gt; parent(n);    for (int i = 0; i &lt; n; ++i) parent[i] = i;    int edgeCount = 0, total = 0;    while (!edges.empty()) &#123;        Edge nextEdge = edges.top();        // cout &lt;&lt; &quot;Get an edge with src=&quot; &lt;&lt; nextEdge.src &lt;&lt; &quot;, dst=&quot; &lt;&lt; nextEdge.dest &lt;&lt; &quot;, wgt=&quot; &lt;&lt; nextEdge.weight &lt;&lt; endl;        edges.pop();        int x = find(parent, nextEdge.src);        int y = find(parent, nextEdge.dest);        // cout &lt;&lt; nextEdge.src &lt;&lt; &quot; is pointing to &quot; &lt;&lt; x &lt;&lt; endl;        // cout &lt;&lt; nextEdge.dest &lt;&lt; &quot; is pointing to &quot; &lt;&lt; y &lt;&lt; endl;        if (x != y) &#123;            // cout &lt;&lt; &quot;Now &quot; &lt;&lt; x &lt;&lt; &quot; is pointing to &quot; &lt;&lt; y &lt;&lt; endl;            parent[x] = y;            total += nextEdge.weight;            edgeCount++;        &#125;    &#125;    if(edgeCount == n - 1) cout &lt;&lt; total &lt;&lt; endl;    else cout &lt;&lt; &quot;orz&quot; ;//&lt;&lt; edgeCount &lt;&lt; endl;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] B3874 [GESP202309 六级] 小杨的握手问题","url":"/2025/07/25/b3874.html","content":"小杨的班级里共有 N\r\n名同学，学号从 0 至 N − 1。\r\n某节课上，老师安排全班同学进行一次握手游戏，具体规则如下：老师安排了一个顺序，让全班\r\nN\r\n名同学依次进入教室。每位同学进入教室时，需要和\r\n已经在教室内 且 学号小于自己\r\n的同学握手。\r\n现在，小杨想知道，整个班级总共会进行多少次握手。\r\n提示：可以考虑使用归并排序进行降序排序，并在此过程中求解。\r\n\r\n输入格式\r\n输入包含 2 行。第一行一个整数 N ，表示同学的个数；第二行 N\r\n个用单个空格隔开的整数，依次描述同学们进入教室的顺序，每个整数在 0 ∼ N − 1\r\n之间，表示该同学的学号。\r\n保证每位同学会且只会进入教室一次。\r\n输出格式\r\n输出一行一个整数，表示全班握手的总次数。\r\n输入输出样例 #1\r\n输入 #1\r\n42 1 3 0\r\n输出 #1\r\n2\r\n输入输出样例 #2\r\n输入 #2\r\n60 1 2 3 4 5\r\n输出 #2\r\n15\r\n说明/提示\r\n样例解释 1:\r\n2\r\n号同学进入教室，此时教室里没有其他同学。\r\n1 号同学进入教室，此时教室里有 2 号同学。1\r\n号同学的学号小于 2\r\n号同学，因此他们之间不需要握手。\r\n3 号同学进入教室，此时教室里有 1, 2 号同学。3 号同学的学号比他们都大，因此 3 号同学需要分别和另外两位同学握手。\r\n0 号同学进入教室，此时教室里有 1, 2, 3 号同学。0 号同学的学号比他们都小，因此 0 号同学不需要与其他同学握手。\r\n样例解释2：\r\n全班所有同学之间都会进行握手，因为每位同学来到教室时，都会发现他的学号是当前教室里最大的，所以他需要和教室里的每位其他同学进行握手。\r\n对于 30% 的测试点，保证 N ≤ 100。\r\n对于所有测试点，保证 2 ≤ N ≤ 3 × 105。\r\n题解\r\n如题面，在归并排序基础上加入一点小料就可以了。\r\n具体来说，由于归并排序会不断分块并从左到右处理，因此每次merge时可认为左侧为已经在教室内，右侧为要依序进入教室的同学。\r\n如果忘记了归并怎么写，可以用\r\nstd::stable_sort(begin, end, cmp) 自定义 cmp\r\n来只实现小 trick。 不过 std::stable_sort 在数组长度 &lt;=\r\n32 的时候会使用插入排序，所以可能要做一些额外小处理。\r\n#include &lt;iostream&gt;#include &lt;cstdint&gt;using namespace std;void merge(uint32_t arr[], uint32_t left, uint32_t mid, uint32_t right, uint64_t &amp;ans)&#123;    uint32_t n1 = mid - left + 1,        n2 = right - mid;    uint32_t *l = new uint32_t[n1],        *r = new uint32_t[n2];    for(uint32_t i=0;i&lt;n1;i++) l[i] = arr[left+i];    for(uint32_t i=0;i&lt;n2;i++) r[i] = arr[mid+1+i];    uint32_t i = 0, j = 0, k = left;    while(i&lt;n1 &amp;&amp; j&lt;n2)&#123;        if(l[i]&gt;=r[j]) arr[k++] = l[i++];        else&#123;            ans += n1 - i;            arr[k++] = r[j++];        &#125;    &#125;    while(i&lt;n1) arr[k++] = l[i++];    while(j&lt;n2) arr[k++] = r[j++];&#125;void mergeSort(uint32_t arr[], uint32_t left, uint32_t right, uint64_t &amp;ans)&#123;    if(left &lt; right)&#123;        uint32_t mid = left + (right - left)/2;        mergeSort(arr, left, mid, ans);        // cout &lt;&lt; &quot;left: &quot;;        // for(uint32_t i=left;i&lt;=mid;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;        // cout &lt;&lt; endl;        mergeSort(arr, mid+1, right, ans);        // cout &lt;&lt; &quot;right: &quot;;        // for(uint32_t i=mid+1;i&lt;=right;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;        // cout &lt;&lt; endl;        merge(arr, left, mid, right, ans);        // cout &lt;&lt; &quot;after: &quot;;        // for(uint32_t i=left;i&lt;=right;i++) cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;        // cout &lt;&lt; endl;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    uint32_t n;    cin &gt;&gt; n;    uint32_t *arr = new uint32_t[n];    for(uint32_t i=0;i&lt;n;i++) cin &gt;&gt; arr[i];    uint64_t s = 0;    mergeSort(arr, 0, n-1, s);    cout &lt;&lt; s;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P11378 [GESP202412 七级] 燃烧","url":"/2025/07/25/p11378.html","content":"小杨有一棵包含 n\r\n个节点的树，其中节点的编号从 1 到 n。节点 i 的权值为 ai。\r\n小杨可以选择一个初始节点引燃，每个燃烧的节点会将其相邻节点中权值严格小于自身权值的在节点间扩散直到不会有新的节点被引燃。\r\n小杨想知道在合理选择初始节点的情况下，最多可以燃烧多少个节点。\r\n\r\n输入格式\r\n第一行包含一个正整数 n，表示节点数量。\r\n第二行包含 n 个正整数 a1, a2, …, an，代表节点权值。\r\n之后 n − 1\r\n行，每行包含两个正整数 ui, vi，代表存在一条连接节点\r\nui 和\r\nvi\r\n的边。\r\n输出格式\r\n输出一个正整数，代表最多燃烧的节点个数。\r\n输入输出样例 #1\r\n输入 #1\r\n56 2 3 4 51 22 32 51 4\r\n输出 #1\r\n3\r\n说明/提示\r\n\r\n\r\n\r\n子任务编号\r\n数据点占比\r\nn\r\n\r\n\r\n\r\n\r\n1\r\n20%\r\n ≤ 10\r\n\r\n\r\n2\r\n20%\r\n ≤ 100\r\n\r\n\r\n3\r\n60%\r\n ≤ 105\r\n\r\n\r\n\r\n对于全部数据，保证有 1 ≤ n ≤ 105，1 ≤ ai ≤ 106。\r\n题解\r\n带条件的图遍历而已，甚至因为严格小都不需要标记了\r\n#include &lt;bits/stdc++.h&gt;using namespace std;int f(vector&lt;int&gt; m[], int c, int p[], int a[])&#123;    if(a[c]) return a[c];    a[c] = 1;    for(int t : m[c])        if(p[t]&lt;p[c])            a[c] += f(m, t, p, a);    return a[c];&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int n;    cin &gt;&gt; n;    int *p = new int[n];    for(int i=0;i&lt;n;i++) cin &gt;&gt; p[i];    vector&lt;int&gt; *m = new vector&lt;int&gt;[n];    for(int i=1;i&lt;n;i++)&#123;        int u, v;        cin &gt;&gt; u &gt;&gt; v;        u--; v--;        m[u].push_back(v);        m[v].push_back(u);    &#125;    int *a = new int[n];    memset(a, 0, sizeof(int)*n);    int x = 0;    for(int i=0;i&lt;n;i++) x = max(x, f(m, i, p, a));    cout &lt;&lt; x;        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] 多线程计算π","url":"/2025/07/25/cal-pi.html","content":"让 AI 写了个多线程计算 π 的程序，非常适合跑分（（（\r\n\r\n#define _USE_MATH_DEFINES#include &lt;iostream&gt;#include &lt;random&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;chrono&gt;#include &lt;atomic&gt;#include &lt;mutex&gt;#include &lt;cmath&gt;// 全局变量std::atomic&lt;unsigned long long&gt; total_in_circle(0);unsigned long long total_points = 0;std::mutex cout_mutex;// 每个线程的工作函数void monte_carlo_pi(unsigned long long points_per_thread, int thread_id) &#123;    std::random_device rd;    std::mt19937 gen(rd());    std::uniform_real_distribution&lt;&gt; dis(-1.0, 1.0);        unsigned long long in_circle = 0;        auto start = std::chrono::high_resolution_clock::now();        for (unsigned long long i = 0; i &lt; points_per_thread; ++i) &#123;        double x = dis(gen);        double y = dis(gen);        if (x * x + y * y &lt;= 1.0) &#123;            ++in_circle;        &#125;    &#125;        auto end = std::chrono::high_resolution_clock::now();    std::chrono::duration&lt;double&gt; elapsed = end - start;        // 累加到全局计数器    total_in_circle += in_circle;        // 输出线程信息    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; thread_id &lt;&lt; &quot; completed in &quot; &lt;&lt; elapsed.count()     &lt;&lt; &quot; seconds (&quot; &lt;&lt; points_per_thread &lt;&lt; &quot; points)&quot; &lt;&lt; std::endl;&#125;int main(int argc, char* argv[]) &#123;    if (argc != 3) &#123;        std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;total_points&gt; &lt;num_threads&gt;&quot; &lt;&lt; std::endl;        return 1;    &#125;        total_points = std::stoull(argv[1]);    unsigned int num_threads = std::stoi(argv[2]);        if (num_threads == 0) &#123;        num_threads = std::thread::hardware_concurrency();        std::cout &lt;&lt; &quot;Using &quot; &lt;&lt; num_threads &lt;&lt; &quot; threads (auto-detected)&quot; &lt;&lt; std::endl;    &#125;        unsigned long long points_per_thread = total_points / num_threads;    unsigned long long remainder = total_points % num_threads;        std::vector&lt;std::thread&gt; threads;    threads.reserve(num_threads);        auto program_start = std::chrono::high_resolution_clock::now();        // 创建线程    for (unsigned int i = 0; i &lt; num_threads; ++i) &#123;        unsigned long long points = points_per_thread;        if (i &lt; remainder) &#123;            points += 1;        &#125;        threads.emplace_back(monte_carlo_pi, points, i);    &#125;        // 等待所有线程完成    for (auto&amp; thread : threads) &#123;        thread.join();    &#125;        auto program_end = std::chrono::high_resolution_clock::now();    std::chrono::duration&lt;double&gt; program_elapsed = program_end - program_start;        // 计算π值    double pi_estimate = 4.0 * total_in_circle.load() / total_points;    double error = std::abs(pi_estimate - M_PI);        // 输出结果    std::cout &lt;&lt; &quot;\\nResults:&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Total points: &quot; &lt;&lt; total_points &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Points in circle: &quot; &lt;&lt; total_in_circle &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Estimated π: &quot; &lt;&lt; pi_estimate &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Actual π: &quot; &lt;&lt; M_PI &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; error &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Total time: &quot; &lt;&lt; program_elapsed.count() &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Points per second: &quot;     &lt;&lt; total_points / program_elapsed.count() &lt;&lt; std::endl;        return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P2114 [NOI2014] 起床困难综合症","url":"/2025/07/25/p2114.html","content":"21\r\n世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm\r\n一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为\r\ndrd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd\r\n的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm\r\n决定前往海底，消灭这条恶龙。历经千辛万苦，atm 终于来到了 drd\r\n所在的地方，准备与其展开艰苦卓绝的战斗。drd\r\n有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd\r\n的防御战线由 n\r\n扇防御门组成。每扇防御门包括一个运算 op 和一个参数 t，其中运算一定是 OR, XOR, AND\r\n中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 x，则其通过这扇防御门后攻击力将变为\r\nx op t。最终\r\ndrd 受到的伤害为对方初始攻击力 x 依次经过所有 n 扇防御门后转变得到的攻击力。\r\n由于 atm 水平有限，他的初始攻击力只能为 0 到 m\r\n之间的一个整数（即他的初始攻击力只能在 0, 1, …, m\r\n中任选，但在通过防御门之后的攻击力不受 m\r\n的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让\r\ndrd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd\r\n受到多少伤害。\r\n\r\n输入格式\r\n输入文件的第 1 行包含 2 个整数，依次为 n, m，表示 drd 有 n 扇防御门，atm 的初始攻击力为 0 到 m 之间的整数。\r\n接下来 n\r\n行，依次表示每一扇防御门。每行包括一个字符串 op 和一个非负整数 t，两者由一个空格隔开，且 op 在前，t 在后，op\r\n表示该防御门所对应的操作，t\r\n表示对应的参数。\r\n输出格式\r\n输出一行一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。\r\n输入输出样例 #1\r\n输入 #1\r\n3 10AND 5OR 6XOR 7\r\n输出 #1\r\n1\r\n说明/提示\r\n【样例说明】\r\natm 可以选择的初始攻击力为 0, 1, …, 10。\r\n假设初始攻击力为 4，最终攻击力经过了如下计算\r\n\r\n4 AND 5 = 4；\r\n4 OR 6 = 6；\r\n6 XOR 7 = 1。\r\n\r\n类似的，我们可以计算出初始攻击力为 1, 3, 5, 7, 9 时最终攻击力为 0，初始攻击力为 0, 2, 4, 6, 8, 10 时最终攻击力为 1，因此atm的一次攻击最多使drd受到的伤害值为\r\n1。\r\n【数据规模与约定】\r\n\r\n\r\n特殊性质 A：存在一扇防御门为 AND 0；\r\n特殊性质 B：所有防御门的操作均相同。\r\n\r\n对于所有数据，保证 2 ≤ n ≤ 105，0 ≤ m ≤ 109，0 ≤ t ≤ 109，且 op 一定为 AND, OR,\r\nXOR 中的一种。\r\n题解\r\n虽然大家都是用真值表法的，但我选择……逆向思维。\r\n反向算出能得出最大值的最小输入，然后砍到范围内，然后再正着算一遍。\r\n有点麻烦，有点牵强，但是容易调试（）\r\n#include &lt;bits/stdc++.h&gt;using namespace std;const size_t N = 1e5;int n, m, i, t[N], tgt = INT_MAX;char op[N];string str;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    for (i = 0; i &lt; n; i++) &#123;        cin &gt;&gt; str &gt;&gt; t[i];        op[i] = str[0];    &#125;    if (m)&#123;        for (i = n - 1; i &gt;= 0; i--) &#123;//        cout &lt;&lt; tgt &lt;&lt; &quot; R&quot; &lt;&lt; op[i] &lt;&lt; &quot; &quot; &lt;&lt; t[i] &lt;&lt; &quot; = &quot;;            switch (op[i]) &#123;            case &#x27;A&#x27;:                tgt &amp;= t[i];                break;            case &#x27;X&#x27;:                tgt ^= t[i];                break;            case &#x27;O&#x27;:                tgt -= tgt &amp; t[i];                break;            default:                break;            &#125;//        cout &lt;&lt; tgt &lt;&lt; endl;        &#125;    &#125;else tgt = m;    if (tgt &gt; m) tgt %= (int)(pow(2, (int)(log2(m)) + 1));    while (tgt &gt; m) tgt &amp;= tgt - 1;//    cout &lt;&lt; &quot;Caculated input: &quot; &lt;&lt; tgt &lt;&lt; endl;    for (i = 0; i &lt; n; i++) &#123;//        cout &lt;&lt; tgt &lt;&lt; &quot; &quot; &lt;&lt; op[i] &lt;&lt; &quot; &quot; &lt;&lt; t[i] &lt;&lt; &quot; = &quot;;        switch (op[i]) &#123;            case &#x27;A&#x27;:                tgt &amp;= t[i];                break;            case &#x27;X&#x27;:                tgt ^= t[i];                break;            case &#x27;O&#x27;:                tgt |= t[i];                break;            default:                break;        &#125;//        cout &lt;&lt; tgt &lt;&lt; endl;    &#125;;    cout &lt;&lt; tgt;    return 0;&#125;\r\n","categories":["编程"]},{"title":"[C++] P1099 [NOIP 2007 提高组] 树网的核","url":"/2025/07/25/p1099.html","content":"设 T = (V, E, W)\r\n是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称\r\nT\r\n为树网（treenetwork），其中 V，E 分别表示结点与边的集合，W 表示各边长度的集合，并设 T 有 n 个结点。\r\n路径：树网中任何两结点 a，b 都存在唯一的一条简单路径，用 d(a, b) 表示以\r\na, b\r\n为端点的路径的长度，它是该路径上各边长度之和。我们称 d(a, b) 为 a, b 两结点间的距离。\r\nD(v, P) = min {d(v, u)},\r\nu 为路径 P 上的结点。\r\n树网的直径：树网中最长的路径称为树网的直径。对于给定的树网 T，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。\r\n偏心距 ECC(F)：树网 T 中距路径 F 最远的结点到路径 F 的距离，即\r\nECC(F) = max {D(v, F), v ∈ V}\r\n任务：对于给定的树网 T = (V, E, W)\r\n和非负整数 s，求一个路径 F，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过\r\ns（可以等于 s），使偏心距 ECC(F) 最小。我们称这个路径为树网\r\nT = (V, E, W)\r\n的核（Core）。必要时，F\r\n可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。\r\n下面的图给出了树网的一个实例。图中，A − B 与 A − C 是两条直径，长度均为\r\n20。点 W 是树网的中心，EF 边的长度为 5。如果指定 s = 11，则树网的核为路径DEFG（也可以取为路径DEF），偏心距为\r\n8。如果指定 s = 0（或 s = 1、s = 2），则树网的核为结点 F，偏心距为 12。\r\n\r\n\r\n输入格式\r\n共 n 行。\r\n第 1 行，两个正整数 n 和 s，中间用一个空格隔开。其中 n 为树网结点的个数，s\r\n为树网的核的长度的上界。设结点编号以此为 1, 2…, n。\r\n从第 2 行到第 n 行，每行给出 3 个用空格隔开的正整数 u, v, w，依次表示每一条边的两个端点编号和长度。例如，2 4 7\r\n表示连接结点 2 与 4 的边的长度为 7。\r\n输出格式\r\n一个非负整数，为指定意义下的最小偏心距。\r\n输入输出样例 #1\r\n输入 #1\r\n5 21 2 52 3 22 4 42 5 3\r\n输出 #1\r\n5\r\n输入输出样例 #2\r\n输入 #2\r\n8 61 3 22 3 2 3 4 64 5 34 6 44 7 27 8 3\r\n输出 #2\r\n5\r\n说明/提示\r\n\r\n对于 40% 的数据，保证 n ≤ 15。\r\n对于 70% 的数据，保证 n ≤ 80。\r\n对于 100% 的数据，保证 2 ≤ n ≤ 300，0 ≤ s ≤ 103，1 ≤ u, v ≤ n，0 ≤ w ≤ 103。\r\n\r\nNOIP2007 提高组第四题\r\n题解\r\n\r\n输入处理：\r\n\r\n读取节点数n和最大允许路径长度s\r\n读取并构建树的邻接表表示\r\n\r\n寻找树的直径：\r\n\r\ngetFarthest(int start)：从起点出发找到最远的节点\r\nbuildDiameter()：通过两次DFS找到树的最长路径（直径）\r\n\r\n预处理距离信息：\r\n\r\n计算每个节点到直径上每个点的距离，存储在g[][]数组中\r\n计算直径上相邻点之间的累积距离，存储在segLen[]中\r\n\r\n枚举所有可能的路径：\r\n\r\n枚举直径上所有可能的子路径[l, r]\r\n检查路径长度是否≤s\r\n对于每个有效路径，计算其偏心距（到其他节点的最大最小距离）\r\n记录最小的偏心距\r\n\r\n\r\n#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 305;const int INF = 1e9;struct Edge &#123;    int to, w;&#125;;vector&lt;Edge&gt; adj[MAXN];int dist[MAXN], pre[MAXN];int diameter[MAXN], dlen;int f[MAXN][MAXN]; // f[i][j] = min distance from node i to diameter segment [0,j]int n, s;void dfs(int u, int p, int d) &#123;    dist[u] = d;    pre[u] = p;    for (auto&amp; e : adj[u]) &#123;        if (e.to != p) &#123;            dfs(e.to, u, d + e.w);        &#125;    &#125;&#125;int getFarthest(int start) &#123;    memset(dist, 0, sizeof(dist));    memset(pre, -1, sizeof(pre));    dfs(start, -1, 0);        int res = start, maxd = 0;    for (int i = 1; i &lt;= n; i++) &#123;        if (dist[i] &gt; maxd) &#123;            maxd = dist[i];            res = i;        &#125;    &#125;    return res;&#125;void buildDiameter() &#123;    int u = getFarthest(1);    int v = getFarthest(u);        dlen = 0;    int cur = v;    while (cur != -1) &#123;        diameter[dlen++] = cur;        cur = pre[cur];    &#125;    reverse(diameter, diameter + dlen);&#125;int getDistance(int u, int v) &#123;    memset(dist, 0x3f, sizeof(dist));    dfs(u, -1, 0);    return dist[v];&#125;int main() &#123;    scanf(&quot;%d %d&quot;, &amp;n, &amp;s);        for (int i = 0; i &lt; n - 1; i++) &#123;        int u, v, w;        scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);        adj[u].push_back(&#123;v, w&#125;);        adj[v].push_back(&#123;u, w&#125;);    &#125;        buildDiameter();        // 预处理：计算每个点到直径上每个点的距离    int g[MAXN][MAXN];    for (int i = 0; i &lt; dlen; i++) &#123;        memset(dist, 0x3f, sizeof(dist));        dfs(diameter[i], -1, 0);        for (int j = 1; j &lt;= n; j++) &#123;            g[j][i] = dist[j];        &#125;    &#125;        // 计算直径上相邻点的距离    int segLen[MAXN] = &#123;0&#125;;    for (int i = 1; i &lt; dlen; i++) &#123;        segLen[i] = segLen[i-1] + getDistance(diameter[i-1], diameter[i]);    &#125;        int ans = INF;        // 枚举所有可能的核心路径    for (int l = 0; l &lt; dlen; l++) &#123;        for (int r = l; r &lt; dlen; r++) &#123;            int pathLen = segLen[r] - segLen[l];            if (pathLen &gt; s) break;                        int ecc = 0;            for (int v = 1; v &lt;= n; v++) &#123;                int minDist = INF;                for (int i = l; i &lt;= r; i++) &#123;                    minDist = min(minDist, g[v][i]);                &#125;                ecc = max(ecc, minDist);            &#125;            ans = min(ans, ecc);        &#125;    &#125;        printf(&quot;%d\\n&quot;, ans);    return 0;&#125;\r\n","categories":["编程"]},{"title":"[Python] P6503 [COCI 2010/2011 #3] DIFERENCIJA","url":"/2025/07/25/p6503.html","content":"给出一个长度为 n 的序列\r\nai，求出下列式子的值：\r\n$$\\sum_{i=1}^{n} \\sum_{j=i}^{n}\r\n(\\max_{i\\le k\\le j} a_k-\\min_{i\\le k\\le j} a_k)$$\r\n即定义一个子序列的权值为序列内最大值与最小值的差。求出所有连续子序列的权值和。\r\n\r\n输入格式\r\n输入第一行一个整数 n，表示序列的长度。\r\n接下来的 n 行，每行一个整数\r\nai，描述这个序列。\r\n输出格式\r\n输出一行一个整数，表示式子的答案。\r\n输入输出样例 #1\r\n输入 #1\r\n3123\r\n输出 #1\r\n4\r\n输入输出样例 #2\r\n输入 #2\r\n47575\r\n输出 #2\r\n12\r\n输入输出样例 #3\r\n输入 #3\r\n43172\r\n输出 #3\r\n31\r\n说明/提示\r\n数据规模与约定\r\n对于 100% 的数据，保证 2 ≤ n ≤ 3 × 105，1 ≤ ai ≤ 108。\r\n说明\r\n题目译自 COCI2010-2011 CONTEST\r\n#3 T5 DIFERENCIJA。\r\n题解\r\ndef calculate_contributions(arr, is_max=True):    n = len(arr)    left = [-1] * n  # 左侧第一个大于(小于)当前元素的索引    right = [n] * n  # 右侧第一个大于等于(小于等于)当前元素的索引    stack = []        # 寻找左侧边界    for i in range(n):        if is_max:            # 对于最大值，寻找左侧第一个大于当前元素的位置            while stack and arr[stack[-1]] &lt;= arr[i]:                stack.pop()        else:            # 对于最小值，寻找左侧第一个小于当前元素的位置            while stack and arr[stack[-1]] &gt;= arr[i]:                stack.pop()                if stack:            left[i] = stack[-1]        stack.append(i)        stack = []    # 寻找右侧边界    for i in range(n-1, -1, -1):        if is_max:            # 对于最大值，寻找右侧第一个大于等于当前元素的位置            while stack and arr[stack[-1]] &lt; arr[i]:                stack.pop()        else:            # 对于最小值，寻找右侧第一个小于等于当前元素的位置            while stack and arr[stack[-1]] &gt; arr[i]:                stack.pop()                if stack:            right[i] = stack[-1]        stack.append(i)        # 计算总贡献    total = 0    for i in range(n):        # 左侧可扩展的距离        left_count = i - left[i]        # 右侧可扩展的距离        right_count = right[i] - i        # 贡献 = 元素值 × 以该元素为最大(小)值的子序列数量        total += arr[i] * left_count * right_count        return totaln = int(input())arr = [int(input()) for _ in range(n)]# 结果 = 所有最大值贡献和 - 所有最小值贡献和result = calculate_contributions(arr, True) - calculate_contributions(arr, False)print(result)\r\n","categories":["编程"]},{"title":"[Python] P2866 [USACO06NOV] Bad Hair Day S","url":"/2025/07/25/p2866.html","content":"农夫约翰有 N\r\n头奶牛正在过乱头发节。\r\n每一头牛都站在同一排面朝右，它们被从左到右依次编号为 1, 2, ⋯, N。编号为 i 的牛身高为 hi。第 N 头牛在最前面，而第 1 头牛在最后面。\r\n对于第 i\r\n头牛前面的第 j 头牛，如果 hi &gt; hi + 1, hi &gt; hi + 2, ⋯, hi &gt; hj，那么认为第\r\ni 头牛可以看到第 i + 1 到第 j 头牛。\r\n定义 Ci\r\n为第 i\r\n头牛所能看到的牛的数量。请帮助农夫约翰求出 C1 + C2 + ⋯ + CN。\r\n\r\n输入格式\r\n输入共 N + 1 行。\r\n第一行为一个整数 N，代表牛的个数。\r\n接下来 N 行，每行一个整数\r\nai，分别代表第\r\n1, 2, ⋯, N 头牛的身高。\r\n输出格式\r\n输出共一行一个整数，代表 C1 + C2 + ⋯ + CN。\r\n输入输出样例 #1\r\n输入 #1\r\n610374122\r\n输出 #1\r\n5\r\n说明/提示\r\n数据规模与约定\r\n对于 100% 的数据，保证 1 ≤ N ≤ 8 × 104，1 ≤ hi ≤ 109。\r\n题解\r\n单调栈求最近较大位置\r\nstack = []ans = &#123;&#125;n = int(input())cows = [int(input()) for _ in range(n)]for i, h in reversed(list(enumerate(cows))):    while stack and cows[stack[-1]] &lt; h: stack.pop()    ans[i] = stack[-1] if stack else n    stack.append(i)#print(ans)print(sum(ans[i]-i-1 for i in range(n)))\r\n","categories":["编程"]},{"title":"[C++] P3372 【模板】线段树 1","url":"/2025/07/25/p3372.html","content":"如题，已知一个数列 {ai}，你需要进行下面两种操作：\r\n\r\n将某区间每一个数加上 k。\r\n求出某区间每一个数的和。\r\n\r\n\r\n输入格式\r\n第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。\r\n第二行包含 n\r\n个用空格分隔的整数 ai，其中第 i 个数字表示数列第 i 项的初始值。\r\n接下来 m 行每行包含 3 或 4\r\n个整数，表示一个操作，具体如下：\r\n\r\n1 x y k：将区间 [x, y] 内每个数加上 k。\r\n2 x y：输出区间 [x, y] 内每个数的和。\r\n\r\n输出格式\r\n输出包含若干行整数，即为所有操作 2 的结果。\r\n输入输出样例 #1\r\n输入 #1\r\n5 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4\r\n输出 #1\r\n11820\r\n说明/提示\r\n对于 15% 的数据：n ≤ 8，m ≤ 10。\r\n对于 35% 的数据：n ≤ 103，m ≤ 104。\r\n对于 100% 的数据：1 ≤ n, m ≤ 105，ai, k\r\n为正数，且任意时刻数列的和不超过 2 × 1018。\r\n【样例解释】\r\n\r\n题解\r\n面向对象的懒加载线段树模版.cpp#include &lt;bits/stdc++.h&gt;using namespace std;class SegmentTreeNode&#123;    const vector&lt;uint64_t&gt;&amp; vec;    uint64_t _sum = 0;    uint64_t pending_change = 0;    const size_t left_bound, right_bound, length, mid;    SegmentTreeNode *left_child = NULL, *right_child = NULL;    bool initialized = false;public:    SegmentTreeNode(const vector&lt;uint64_t&gt;&amp; v, const size_t lb, const size_t rb) :        vec(v), left_bound(lb), right_bound(rb), length(rb - lb), mid(lb + length / 2)    &#123;        if (lb &gt; rb) throw new invalid_argument(&quot;lb cannot be greater than rb&quot;);    &#125;;    SegmentTreeNode(const vector&lt;uint64_t&gt;&amp; v) : vec(v), left_bound(0), right_bound(v.size()-1), length(v.size()-1), mid(length/2) &#123;&#125;    ~SegmentTreeNode()    &#123;        if (left_child != NULL) delete left_child;        if (right_child != NULL) delete right_child;    &#125;    void range_add(const size_t lb, const size_t rb, const uint64_t n)    &#123;        if (lb &gt; rb || lb &lt; left_bound || rb &gt; right_bound) throw new invalid_argument(&quot;invalid bounds!&quot;);        if (lb == left_bound &amp;&amp; rb == right_bound) return add_pending(n);        _sum += n * (rb - lb + 1);        const bool at_left = lb &lt;= mid, at_right = rb &gt; mid;        if (at_left) left()-&gt;range_add(lb, min(rb, mid), n);        if (at_right) right()-&gt;range_add(max(lb, mid + 1), rb, n);    &#125;    uint64_t range_sum(const size_t lb, const size_t rb)    &#123;        if (lb &gt; rb || lb &lt; left_bound || rb &gt; right_bound) throw new invalid_argument(&quot;invalid bounds!&quot;);        if (lb == left_bound &amp;&amp; rb == right_bound) return sum();        const bool at_left = lb &lt;= mid, at_right = rb &gt; mid;        if (pending_change)        &#123;            left()-&gt;add_pending(pending_change);            right()-&gt;add_pending(pending_change);            _sum += pending_change * (length + 1);            pending_change = 0;        &#125;        uint64_t rs = 0;        if (at_left) rs += left()-&gt;range_sum(lb, min(rb, mid));        if (at_right) rs += right()-&gt;range_sum(max(lb, mid + 1), rb);        return rs;    &#125;    uint64_t sum()    &#123;        if (!initialized)        &#123;            if (length)            &#123;                _sum = left()-&gt;sum() + right()-&gt;sum();            &#125;            else            &#123;                _sum = vec[left_bound];            &#125;            initialized = true;        &#125;        return _sum + pending_change * (length + 1);    &#125;    SegmentTreeNode* left()    &#123;        if (!length) return NULL;        if (left_child == NULL) left_child = new SegmentTreeNode(vec, left_bound, mid);        return left_child;    &#125;    SegmentTreeNode* right()    &#123;        if (!length) return NULL;        if (right_child == NULL) right_child = new SegmentTreeNode(vec, mid + 1, right_bound);        return right_child;    &#125;    void add_pending(const uint64_t n)    &#123;        pending_change += n;    &#125;&#125;;int main()&#123;    vector&lt;uint64_t&gt; a;    uint64_t n, m;    cin &gt;&gt; n &gt;&gt; m;    a.reserve(n);    while(n--)&#123;        uint64_t x;        cin &gt;&gt; x;        a.emplace_back(x);    &#125;        SegmentTreeNode tree(a);        while(m--)&#123;        uint64_t t, x, y, k;        cin &gt;&gt; t;        switch(t)&#123;        case 1:            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;            tree.range_add(x-1, y-1, k);            break;        case 2:            cin &gt;&gt; x &gt;&gt; y;            cout &lt;&lt; tree.range_sum(x-1, y-1) &lt;&lt; endl;            break;        &#125;    &#125;        return 0;&#125;\r\n","categories":["编程"]}]